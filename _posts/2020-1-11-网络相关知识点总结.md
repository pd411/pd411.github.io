---
layout: article
title: 网络相关知识点总结
aside:
  toc: true
sidebar:
  nav: docs
---

# 网络协议
## 网络分层的意义
- 各层之间相互独立，高层是不需要知道底层的功能如何实现的，只需要知道通过与底层的接口就可以获得所需要的服务；
- 灵活性好，各层都可以采用最恰当的技术实现；
- 易于实现和标准化，由于采用了规范的层次结构去组织网络功能与协议，因为可以将计算机网络复杂的通信过程，划分为有序的连续动作与有序的交互过程，有利于将网络复杂的通信工作过程简化为一系列可以控制和实现的功能模块。
 
<br/>

## 两种网络分层模型
### OSI 模型
即开放系统互连（Open System Interconnection），是网络通信的一种通用框架，分为七层，并且定义了在每一层上数据的处理方式。

<br/>

![OSI模型七层]({{site.url}}/assets/images/network/image001.gif "OSI模型七层")

<br/>

- **第七层 -- 应用层（Application）**：针对特定应用的协议
它的作用是为**应用程序提供服务**并规定应用程序中通讯相关的细节，也就是为应用提供服务。常见的协议有HTTP、FTP、TELNET、SMTP等。
  - HTTP：超文本传输协议，提供数据供浏览器使用；
  - FTP：文件传输协议，用来在客户机和FTP服务器之间传输文件；
  - DHCP：动态主机配置协议，DHCP服务器为客户机动态分配IP地址；
  - POP3:邮件接收协议，用于从POP3服务器接收邮件；
  - SMTP：邮件发送协议，用于通过SMTP服务器发送邮件。

<br/>

- **第六层 -- 表示层（Presentation）**：设备固有数据格式和网络标准数据格式的转换
这层的主要功能是：**转换**、**压缩**和**加密**。它的作用是将应用处理的信息转化为适合网络输出的格式，或者将来自下一层的数据转换为上一层能处理的格式。它主要负责数据格式的转换。具体来说，就是将设备固有的数据格式转换为网络标准格式。常见的协议有ASCII、SSL/TLS等。

<br/>

- **第五层 -- 会话层（Session）**：建立、管理和维护通信，管理传输层以下的分层
这层的作用就是为**创建**、**管理**和**终止会话**提供必要的方法。这些方法一般以API的形式出现，常用的API有NetBIOS（Network Basic Input/Output Interface，网络基本输入/输出系统）、RPC（Remote Procedure Cell，远程过程调用）和Socket API。可以理解为两个应用程序进程之间的逻辑连接，两个应用程序通过这个逻辑连接在一段时间内交换数据。

<br/>

- **第四层 -- 传输层（Transprt）**：管理两个节点之间的数据传输（确保数据被可靠地传送给目标地址）
传输层起着**可靠传输**的作用。这里的“传输”指的是**端对端**或者**主机对主机**的传输。只在通信双发节点进行处理，而不需要在路由器上处理。
传输层上最重要的两个协议是**TCP（面向连接的协议，Connection-Oriented）**和**UDP（无连接的协议，Connection-Less）**。

<br/>

- **第三层 -- 网络层（Network）**：地址管理和路由选择
网络层负责将**数据传输到目标地址**，目标地址可以使用多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择。主要由IP、ICMP两个协议组成。
网络层将数据从发送端的主机发送到接收端的主机，两台主机可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址用的是IP地址，IP地址通过不断转发到更近的IP地址，最终可以到达目标地址。

<br/>

- **第二层 -- 数据链路层（Data Link）**：互连设备之间传送和识别数据帧
数据链路层负责**物理层面上互连的节点之间的通信传输**。它关心的是如何把**数据发送到本地网络中去**，平时常说的**LAN**技术，如以太网(Ethernet)、令牌环网(Token Ring)、光纤分布数据接口(FDDI)和802.11(WIFI)都定义在这一层。
数据链路层又分为两个子层：**逻辑链路控制层（Logical Link Control）**和**介质访问控制层（Media Access Control）**。
数据链路层有一个重要的概念，即**MAC地址**，可以称为物理地址、硬件地址、以太网地址等。每个网卡（Network Interface Card）都有一个**唯一的MAC地址**，数据链路层通过MAC地址来确保数据能够正确被发送到目标设备。MAC地址有一个**48位二进制整数**，通常的表示方法是用-隔开的6个十六进制整数，如14-FE-B5-B0-2B-96。

<br/>

- **第一层 -- 物理层（Physical）**：将数据0、1转换为电压和脉冲光传输给屋里的传输介质
物理层位于OSI的底层，所有其他层的数据最终都必须经由物理层才能发送出去。物理层的功能包括：
  - **硬件规范的定义**，如电缆、连接器、无线接收器等的工作方式，网卡、集线器等网络设备也工作在物理层；
  - **编码和信号**，物理层把计算机中的二进制0和1转换成可以在物理介质上传输的信号；
  - 再把数据转换成信号后，物理层负责**信号的实际发送和接收**。
 
<br/>

****

<br/>

### TCP/IP 模型
TCP/IP分层模型被称作因特网分层模型（Internet Layering Model）、因特网参考模型（Internet Reference Model），一共分为四层：

- **第四层 -- 应用层（Application）**：TCP/IP模型的**应用层**相当于OSI模型的**会话层**、**表示层**和**应用层**，常用协议FTP(文件传输协议)、DNS(域名系统)、HTTP协议、Telnet(网络远程访问协议)。
<br/>

- **第三层 -- 传输层（Transport）**：提供**TCP**和**UDP**两个协议，主要功能是**数据格式化**、**数据确认**和**丢失重传**等。
<br/>

- **第二层 -- 网络层（Network）**：该层负责**相同和不同网络中计算机之间的通信**，主要处理**数据包**和**路由**。数据包是网络传输的最小数据单位，通过某条传输路线将数据包传给对方，如IP协议、ICMP协议、IGMP协议。在IP层中，**ARP协议**用于将**IP地址转换为物理地址**，**ICMP协议**用于**报告差错**和**传送控制信息**，**IP协议**在TCP/IP协议组中处于核心地位。
<br/>

- **第一层 -- 网络接口层（Network Interface）**：该层对实际的**网络媒介的管理**，包括操作系统中的设备驱动程序和计算机相对的网络接口卡。
 
<br/>

### OSI模型和TCP/IP模型的相同点
- 都是采用协议分层的方法；
- 层次协议的功能大体相同；
- 两种模型都可以解决异构网的互连；
- 都是计算机通信的国际标准，OSI原则上是国际通用，TCP/IP工业上使用较多；
- 都提供TCP和UDP；
- 都是基于一种协议集的概念，协议集是一组完成特定功能的相互独立的协议。
 
<br/>

### OSI模型和TCP/IP模型的差异
- TCP/IP一开始就考虑到多种异构网的互连问题，并将网际协议IP作为TCP/IP的重要组成部分。ISO和CCITT最初只考虑到全世界都使用一种统一的标准公用数据网将各种不同的系统互连在一起，后来，ISO意识到网际协议IP的重要性，然而已经来不及了，只好在网络层划分一个子层来完成类似TCP/IP中的IP的作用。

- TCP/IP一开始就对面对连接服务和无连接服务并重，而OSI在开始的时只强调面向连接这一种服务。OSI之后才开始制定另一种无连接服务的有关标准。

- TCP/IP较早就有很好的网络管理功能，而OSI到后来才考虑这个问题。

- TCP/IP的不足：TCP/IP模型对“服务”，“协议”和“接口”等概念没有很清楚的区分开，TCP/IP模型的通用性比较差。很难用来描述其他种类的协议栈，TCP/IP的网络接口严格来说并不是一个层次而仅仅是一个接口。

<br/>

****

<br/>

# TCP/IP 协议
在`TCP/IP`协议中，不同协议层对包都进行了封装：
- 从用户的数据报文进过封装传递给传输层；
- 传输层封装TCP首部，上一层传递过来的数据为TCP数据，传递给网络层；
- 网络层封装IP首部，上一层传递过来的数据为IP数据，传递给数据链路层；数据链路层封装帧首部；
- 帧数据是最终在物理网络上传输字节序列。

过长的IP报文段可能会被分包传输。拆包的过程则是当帧数据到达时，沿着协议栈从底自上的进行拆解。

数据从上到下封装的格式为：`比特（bit） -> 帧（frame） -> 包（packet） -> 段（segment） -> 数据（data）`。

!["tcp/ip的数据封包与拆解"]({{site.url}}/assets/images/network/image002.png "tcp/ip的数据封包与拆解")

下面的内容将从TCP/IP模型的应用层到网络接口层，进行详解。

<br/>

****

<br/>

# 应用层
应用层为`tcp/ip协议`的最上层，也就是我们开发的应用程序，位于这一层。在这一层包含一些协议，比如：`DNS(域名解析协议)`、`SMTP(简单邮件传输协议)`、`FTP(文件传输协议)`、`HTTP(超文本传输协议)`、`Telnet(网络远程协议)`等。

## DNS 域名解析协议
### 域名注册
- **domain name 域名**
域名是一个访问网站或者是应用程序的名字，例如，当用户在浏览器上输入的`www.example.com`。为了是你的网站或者是应用程序在互联网上可用，就必须注册一个域名。
 

- **domain registrar 域注册商**
域注册商是一个公司经ICANN（互联网名称和数字地址分配机构）认可的公司，可以处理特定顶级域名（TLD）的域名注册。例如，Amazon Registrar, Inc. 是一个域名注册商对于`.com`、`.net`、`.org`。
 

- **domain registry 域注册局**
域注册局是一个公司有权利去销售一些特定的顶级域名（TLD）。域注册表定义了用于注册域的规则，例如地理TLD的居住要求。 域注册中心还维护具有相同TLD的所有域名的权威数据库。 注册表的数据库包含每个域的信息，例如联系信息和名称服务器。
 

- **domain reseller 域代理商**
域代理商是一个公司为注册服务商出售域名。
 

- **top-level domain (TLD) 顶级域名**
顶级域名是域名的最后一部分，例如`.com`、`.net`、`.org`。
 
<br/>

### DNS 域名解析协议概念
- **A 记录**
A记录，又称主机记录，是将一个域名解析成一个IP地址。当访问一个域名时DNS会通过A记录解析出相对应的IP地址，以达到后续访问的目的。


- **CNAME 记录**
CNAME记录，又称别名记录，是将一个域名，映射到另外一个域名。这两个别名的全称就`http://www.mydomain.com/`和`mail.mydomain.com`。实际上他们都指向 `host.mydomain.com`。


- **DNS 解析**
DNS解析的过程就是寻找那台机器上有你需要的资源的过程。当在浏览器上输入一个地址时，其实并不是输入的网站真正意义上的地址。互联网上每台计算机的唯一标识是它的IP地址，但IP地址并不方便记忆。用户更喜欢用方便记忆的网站去寻找互联网上的其它计算机，也就是用户输入在浏览器上的网站。一个网站到IP地址的转换，这个过程就是DNS解析。查找顺序：`浏览器缓存 -> 操作系统缓存 -> 本地host文件 -> 路由器缓存 -> ISP DNS缓存 -> 顶级DNS服务器`。
  - **浏览器缓存**：首先会向浏览器的缓存中读取上一次访问的记录；
  - **操作系统缓存**：查找存储在系统运行内存中的缓存；
  - **host文件**：查看本地硬盘的host文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用host文件里面的ip地址；
  - **路由器缓存**：有些路由器也有DNS缓存的功能，访问过的域名会存在路由器上；
  - **ISP DNS缓存**：互联网服务提供商也会提供DNS服务。在本地查找不到的情况下，就会向ISP进行查询，ISP会在当前服务器的缓存内查找是否有记录，如果有，则返回这个IP，若没有，则会开始向顶级域名服务器请求查询。
  - **顶级DNS服务器**：根域名收到请求后，会判别这个域名(.com)是授权给那台服务器管理，并返回这个顶级DNS服务器的IP。请求者收到这台顶级DNS的服务器IP后，会向该服务器发起查询，如果该服务器无法解析，该服务器就会返回下一季的DNS服务器IP，本机继续查找，直到服务器找到主机。

<br/>

### dig 命令
通过`dig`命令查询主机地址的信息：
!["dig www.baidu.com"]({{site.url}}/assets/images/network/image003.png "dig www.baidu.com信息")
- `dig`命令的版本以及输入参数的信息
```
; <<>> DiG 9.10.6 <<>> www.baidu.com
;; global options: +cmd
```
- `dig`命令返回的DNS解析的技术信息
```
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 13539
;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1
```
- 查询的域名信息
```
;; QUESTION SECTION:
;www.baidu.com.			IN	A
```
- `dig`查询到的结果，其中A为A记录，CNAME为CNAME记录
```
;; ANSWER SECTION:
www.baidu.com.		182	IN	CNAME	www.a.shifen.com.
www.a.shifen.com.	151	IN	A	163.177.151.110
www.a.shifen.com.	151	IN	A	163.177.151.109
```
- 剩余数据记录
```
;; Query time: 12 msec
;; SERVER: 120.80.88.88#53(120.80.88.88)
;; WHEN: Mon Jan 13 18:15:10 CST 2020
;; MSG SIZE  rcvd: 101
```

<br/>

****

<br/>

## HTTP 协议
**HTTP（超文本传输协议）** 是一个用于传输超媒体文档（例如HTML）的应用层协议。它是为Web浏览器与Web服务器之间的通信而设计的，但也可以用于其他目的。HTTP 遵循经典的**CS（客户端-服务器端）模型**，客户端打开一个连接以发送请求，然后等待它收到服务器端响应。HTTP 是**无状态协议**，这意味着服务器不会再两个请求之间保留任何数据（状态）。该协议虽然通常基于**TCP/IP层**，但可以在任何可靠的传输层上使用；也就是说，不像UDP，它是一个不会静默丢失消息的协议。RUDP-作为UDP的可靠化升级版本-是一个合适的替代选择。

<br/>

### HTTP 的基本性质
- **HTTP 是简单的**：虽然下一代`HTTP/2`协议将HTTP消息封装到了帧（frames）中，HTTP大体上还是被设计得简单易读；

- **HTTP 是可拓展的**：在`HTTP/1.0`中出现的`HTTP headers`让协议扩展变得非常容易。只要服务端和客户端就新`headers`达成语义一致，新功能就可以被轻松加入进来。


- **HTTP是无状态，有会话的**：无状态表示在同一个连接中，两个执行成功的请求之间是没关系的。这就会出现一个问题，用户没有办法在同一个网站进行连续交互，比如在一个电商网站里，用户把商品添加入购物车，当切换页面再次添加商品，这两次添加商品之间没有关系，浏览器无法知道用户最终选择了哪些商品。而可以使用`HTTP Cookies`，使得每次请求都能共享相同的上下文信息，达成相同的状态。


- **HTTP 和连接**：一个连接是由**传输层**来控制的，这从根本上不属于HTTP的范围。HTTP并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。在互联网中，有两个最常用的传输层协议：TCP是可靠的，而UDP不是。因此，HTTP依赖于面向连接的TCP进行消息传递，但连接并不是必须的。

<br/>

### HTTP 消息
HTTP消息是服务器和客户端之间交换数据的方式。有两种类型的消息：请求（request）—— 客户端发送消息给服务器；响应（response）—— 来自服务器的应答。

HTTP 请求和响应具有相似的结构，由以下部分组成：
- 一行起始行用于描述要执行的请求，或者是对应的状态，成功或失败。这个起始行总是单行的。
- 一个可选的 HTTP 头集合指明请求或描述消息征文。
- 一个空行指示所有关于请求的元数据已经发送完毕。
- 一个可选的包含请求相关数据的正文（比如HTML表单），或者响应相关的文档。正文的大小有起始行的HTTP头来指定。

<br/>

### HTTP 请求结构
**1. 起始行**：HTTP请求是由客户端发出的消息，用来使服务器执行动作。*起始行（start-line）*包含三个元素：

`POST / HTTP 1.1`

`GET /background.png HTTP/1.0`

`HEAD /test.html?query=alibaba HTTP/1.1`

`OPTIONS /anypage.html HTTP/1.0`

`GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1`

- 一个 *HTTP方法（HTTP method）*，例如`GET`、`PUT`和`HEAD`，描述要执行的动作。
- *请求目标（request target）*，通常是一个`URL`，或者是协议、端口和域名的绝对路径，通常以请求的环境为特征。请求的格式因不同的HTTP 方法而异。可以是：
  - 一个绝对路径，末尾跟上'?'和查询字符串；
  - 一个完整的URL，被称为*绝对形式（absolute form）*；
  - 由域名和可选端口（以`:`为前缀）组成的 URL 的authority component。仅在使用`CONNECT`建立HTTP隧道时才使用。
  `CONNECT developer.mozilla.org:80 HTTP/1.1`
  - *星号形式（asterisk form）*，一个简单的的星号(`*`)，配合`OPTIONS`方法使用，代表整个服务器。
  `OPTION * HTTP/1.1`
- *HTTP 版本（HTTP version）*，定义了剩余报文的结构，作为对期望的响应版本的指示符。


**2. Headers**：来自请求的 HTTP headers 遵循和 HTTP header 相同的基本结构：不区分大小写的字符串，紧跟着的冒号(`:`)和一个结构取决于 header 的值。整个 header（包括值）由一行组成，这一行可以相当长。
   - *General headers*，例如`Via`，适用于整个报文；
   - *Request headers*，例如`User-Agent`、`Accept-Type`，通过进一步的定义，或者给定上下文(例如`Referer`)，或者进行有条件的限制 (例如`If-None`) 来修改请求。
   - *Entity headers*，例如`Content-Length`，适用于请求的 body。显然，如果请求中没有任何 body，则不会发送这样的头文件。
!["http request headers"]({{site.url}}/assets/images/network/HTTP_Request_Headers2.png "http request headers")


**3. Body**：请求的最后一部分是它的body。不是所有的请求都有一个 body：例如获取资源的请求，`GET`，`HEAD`，`DELETE` 和 `OPTIONS`，通常它们不需要 body。 有些请求将数据发送到服务器以便更新数据：常见的的情况是 `POST` 请求（包含 HTML 表单数据）。Body 大致分为两类：
- *Single-resource bodies*，由一个单文件组成。该类型 body 由两个 header 定义： `Content-Type` 和 `Content-Length`.
- *Multiple-resource bodies*，由多部分 body 组成，每一部分包含不同的信息位。通常是和 `HTML Forms` 连系在一起。

<br/>

### HTTP 响应结构
**1. 状态行**：HTTP 响应的起始行被称作 *状态行（status line）*，包含以下信息：
`HTTP/1.1 404 Not Found`
- *协议版本*，通常为 `HTTP/1.1`。
- *状态码（status code）*，表明请求是成功或失败。常见的状态码是 `200`，`404`。
- *状态文本（status text）*。一个简短的，纯粹的信息，通过状态码的文本描述，帮助人们理解该 HTTP 消息。


**2. Headers**：响应的 HTTP headers 遵循和任何其它 header 相同的结构：不区分大小写的字符串，紧跟着的冒号 (`:`) 和一个结构取决于 header 类型的值。 整个 header（包括其值）表现为单行形式。响应头可分为：
- *General headers*，例如`Via`，适用于整个报文。
- *Response headers*，例如`Vary`和`Accept-Ranges`，提供其它不符合状态行的关于服务器的信息。
- *Entity headers*，例如`Content-Length`，适用于请求的 body。显然，如果请求中没有任何 body，则不会发送这样的头文件。
!["http response headers"]({{site.url}}/assets/images/network/HTTP_Response_Headers2.png "http response headers")


**3. Body**：响应的最后一部分是 body。不是所有的响应都有 body：具有状态码 (如`201`或`204`) 的响应，通常不会有 body。
Body 大致可分为：
- *Single-resource bodies*，由已知长度的单个文件组成。该类型 body 由两个 header 定义`Content-Type`和`Content-Length`。
- *Single-resource bodies*，由*未知*长度的单个文件组成，通过将`Transfer-Encoding`设置为 chunked 来使用 chunks 编码。
- *Multiple-resource bodies*，由多部分 body 组成，每部分包含不同的信息段。但这是比较少见的。

<br/>

### HTTP 请求方法
HTTP 定义了一组请求方法，以表明要对给定资源执行的操作。指示针对给资源要执行的期望动作。每个请求方法都实现了不同的语义，但一些共同的特征由一组恭喜那个：例如一个请求方法可以是 *safe*，*idempotent*，*cacheable*。


> *safe 安全*：一个 HTTP方法是安全的，就意味着不会它不会修改服务器的状态。换句话说，一个安全的方法，它是 read-only只读 操作。 `GET` 、 `HEAD` 、 `OPTIONS` 是安全的。所有安全的方法，同样是幂等的。但幂等的方法不一定是安全的，例如 `PUT` 和 `DELETE`。
*idempotent 幂等*：一个 HTTP方法 是幂等的，就意味着客户端发送一个特定的请求，无论一次或者是多次，造成的影响都是一样的，同时保持服务器是相同的状态。换句话说，一个幂等的方法不应该有任何副作用。`GET`、 `HEAD`、 `PUT` 和 `DELETE` 方法都是幂等的，但 `POST` 不是。 所有的安全的方法同样是幂等的。


**`GET`**

GET 方法请求一个指定资源的表示形式。使用GET的请求应该只被用于获取数据。


**`HEAD`**

HEAD 方法请求一个与GET请求 的响应相同的响应，但没有body。


**`POST`**

POST 方法用于将body提交到指定的资源，通常导致在服务器上的状态变化或者副作用。


**`PUT`**

PUT方法用请求有效载荷替换目标资源的所有当前表示。
PUT 与 POST 方法的区别在于，PUT方法是幂等的：调用一次与连续调用多次是等价的（即没有副作用），而连续调用多次POST方法可能会有副作用，比如将一个订单重复提交多次。

**`DELETE`**

DELETE方法删除指定的资源。


**`CONNECT`**

CONNECT方法建立一个到由目标资源标识的服务器的隧道。


**`OPTIONS`**

OPTIONS方法用于描述目标资源的通信选项。


**`TRACE`**

TRACE方法沿着到目标资源的路径执行一个消息环回测试。


**`PATCH`**

PATCH方法用于对资源应用部分修改。

<br/>

### HTTP 响应代码
HTTP 响应状态代码指定特定 HTTP请求 是否已经成功完成。响应分为五类：信息响应（100-199），成功响应（200-299），重定向（300-399），客户端错误（400-499）和服务器错误（500-599）。


#### 消息响应

**`100 Continue`**

这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。
为了让服务器检查请求的首部，客户端必须在发送请求实体前，在初始化请求中发送 `Expect: 100-continue` 首部并接收 `100 Continue` 响应状态码。

**`101 Switching Protocol`**

该代码是响应客户端 `Upgrade` 标头发送的，并且指示服务器也正在切换的协议。


#### 成功响应

**`200 OK`**

请求成功。成功的含义取决于HTTP方法：
- GET：资源已被提取并在消息正文中传输。
- HEAD：实体标头位于消息正文中。
- POST：描述动作结果的资源在消息体中传输。
- TRACE：消息正文包含服务器收到的请求消息。


**`201 Created`**

该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应。


**`202 Accepted`**

请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。
服务器已接受到请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会，也可能不会被执行。在异步操作的场合下，发送这种状态码更加方便。


**`203 Non-Authoritative Information`**

服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。

**`204 No Content`**

HTTP `204 No Content` 成功状态响应码，表示该请求已经成功了，但是客户端客户不需要离开当前页面。默认情况下 204 响应是可缓存的。一个 `ETag` 标头包含在此类响应中。 
使用惯例是，在 `PUT` 请求中进行资源更新，但是不需要改变当前展示给用户的页面，那么返回 204 No Content。如果创建了资源，则返回 `201 Created` 。如果应将页面更改为新更新的页面，则应改用 `200 OK` 。

**`205 Reset Content`**

服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，**立即重置表单**，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。

**`206 Partial Content`**

服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现**断点续传**或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。


#### 重定向

**`300 Multiple Choice`**

表示该请求拥有多种可能的响应。用户代理或者用户自身应该从中选择一个。由于没有如何进行选择的标准方法，这个状态码极少使用。
假如服务器可以提供一个优先选择，那么它应该生成一个 `Location` 首部。

**`301 Moved Permanently`**

说明请求的资源已经被移动到了由`Location`头部指定的url上，是固定的不会再改变。搜索引擎会根据该响应修正。
尽管标准要求浏览器在收到该响应并进行重定向时不应该修改http method和body，但是有一些浏览器可能会有问题。所以最好是在应对 `GET` 或 `HEAD` 方法时使用 `301` ，其他情况使用 `308` 来替代 `301`。

**`302 Found`**

说明请求的资源被暂时的移动到了由 `Location` 头部指定的 `URL` 上。浏览器会重定向到这个 `URL`但是搜索引擎不会对该资源的链接进行更新。
即使规范要求浏览器在重定向时保证请求方法和请求主体不变，但并不是所有的用户代理都会遵循这一点，你依然可以看到有缺陷的软件的存在。所以推荐仅在响应 `GET` 或 `HEAD` 方法时采用 `302` 状态码，而在其他时候使用 `307 Temporary Redirect` 来替代，因为在这些场景下方法变换是明确禁止的。
在确实需要将重定向请求的方法转换为 `GET` 的场景下，可以使用 `303 See Other`。例如在使用 `PUT` 方法进行文件上传操作时，需要返回确认信息（例如“你已经成功上传了xyz”）而不是上传的资源本身，就可以使用这个状态码。

**`303 See Other`**

通常作为 `PUT` 或 `POST` 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 `GET`。

**`304 Not Modified`**

说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在一些安全的方法（safe），例如 `GET` 或 `HEAD` 或在请求中附带了头部信息： `If-None-Match` 或`If-Modified-Since`。
如果是 `200 OK` ，响应会带有头部 `Cache-Control`, `Content-Location`, `Date`, `ETag`, `Expires`，和 `Vary`。

**`307 Temporary Redirect`**

请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。

**`308 Permanent Redirect`**

这意味着资源现在永久位于由 `Location:` HTTP Response 标头指定的另一个 `URI`。 这与 `301 Moved Permanently` HTTP 响应代码具有相同的语义，但用户代理不能更改所使用的 `HTTP` 方法：如果在第一个请求中使用 `POST`，则必须在第二个请求中使用 `POST`。

> 注：`303`、`307` 和 `308` 是 `HTTP/1.1` 对 `302` 和 `301` 的规范。但工业上大多数情况还是使用 `302` 和 `301` 状态码。

<br/>

#### 客户端响应

**`400 Bad Request`**

1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。
2、请求参数有误。

**`401 Unauthorized`**

指的是由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。
这个状态码会与 `WWW-Authenticate` 首部一起发送，其中包含有如何进行验证的信息。
这个状态类似于 `403`， 但是在该情况下，依然可以进行身份验证。

**`403 Forbidden`**

指的是服务器端有能力处理该请求，但是拒绝授权访问。
这个状态类似于 `401`，但进入该状态后不能再继续进行验证。该访问是长期禁止的，并且与应用逻辑密切相关（例如不正确的密码）。

**`404 Not Found`**

指的是服务器端无法找到所请求的资源。

**`405 Method Not Allowed`**

表明服务器禁止了使用当前 `HTTP` 方法的请求。需要注意的是，`GET` 与 `HEAD` 两个方法不得被禁止，当然也不得返回状态码 `405`。

**`406 Not Acceptable`**

请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。
但实际情况下，这个状态码很少使用，因为为保证用户网站的体验度，一般会将相关的消息头忽略，同时给用户提供一个看得见摸得着的页面。

**`407 Proxy Authentication Required`**

指的是由于缺乏位于浏览器与可以访问所请求资源的服务器之间的代理服务器（proxy server）要求的身份验证凭证，发送的请求尚未得到满足。

**`408 Request Timeout`**

请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。

**`409 Conflict`**

表示请求与服务器端目标资源的当前状态相冲突。
冲突最有可能发生在对 `PUT` 请求的响应中。例如，当上传文件的版本比服务器上已存在的要旧，从而导致版本冲突的时候，那么就有可能收到状态码为 409 的响应。

<br/>

#### 服务器响应

**`500 Internal Server Error`**

服务器遇到了不知道如何处理的情况。
这个错误代码是一个通用的“万能”响应代码。有时候，对于类似于 500 这样的错误，服务器管理员会更加详细地记录相关的请求信息来防止以后同样错误的出现。

**`501 Not Implemented`**

此请求方法不被服务器支持且无法被处理。只有 `GET` 和 `HEAD` 是要求服务器支持的，它们必定不会返回此错误代码。
`501` 可以被缓存。

**`502 Bad Gateway`**

表示作为网关或代理角色的服务器，从上游服务器（如tomcat、php-fpm）中接收到的响应是无效的。

**`503 Service Unavailable`**

服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。

**`504 Gateway Timeout`**

表示扮演网关或者代理的服务器无法在规定的时间内获得想要的响应。

**`505 HTTP Version Not Supported`**

服务器不支持请求中所使用的HTTP协议版本。

<br/>

### HTTP Headers
以下只列举出部分 HTTP headers，[更多内容点击](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers "点击")。

#### Request Headers

| Header | 说明 | 示例 |
|--------|------|-----|
| Accept | 告知服务器，客户端可以处理的内容类型 | Accept: text/plain |
| Accept-Charset | 浏览器可以接受的字符编码集 | Accept-Charset: utf-8 |
| Accept-Encoding | 告知服务器，客户端能够理解的内容编码方式 | Accept-Encoding: gzip |
| Accept-Language | 客户端可以声明可以理解的语言 | Accept-Language: en |
| Cache-control | 被用于在http请求和响应中，通过指定指令来实现缓存机制 | Cache-control: max-age=60 |
| Cookie | 是一个请求首部，其中含有先前由服务器通过 Set-Cookie  首部投放并存储到客户端的 HTTP cookies | Cookie: PHPSESSID=298zf09hf012fh2 |
| User-Agent | 首部包含了一个特征字符串，用来让网络协议的对端来识别发起请求的用户代理软件的应用类型、操作系统、软件开发商以及版本号 | User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36 |

#### Response Headers

| Header | 说明 | 示例 |
|--------|------|-----|
| Content-length | 用来指明发送给接收方的消息主体的大小 | Content-length: 24211 |
| Content-encoding | 用于对特定媒体类型的数据进行压缩 | Content-encoding: gzip |
| Content-Type | 设置响应体的媒体资源类型 | Content-Type: text/html; charset=utf-8 |
| Date | 报文创建的日期和时间 | Date: Wed, 21 Oct 2015 07:28:00 GMT |
| Expires | 日期/时间， 即在此时候之后，响应过期 | Expires: Wed, 21 Oct 2015 07:28:00 GMT |

<br/>

### HTTP/1.x 的连接管理
HTTP 的传输协议主要依赖于 TCP 来提供从客户端到服务器之间的连接。在早期，HTTP 使用一个简单的模型来处理这样的连接。这些连接的生命周期是短暂的：每发起一个请求是都会创建一个新的连接，并在收到响应时立即关闭。

这样每一次的 TCP连接 都是会造成相当大的资源的耗费，并且效率低下。

但在 HTTP/1.1 过后有了**长连接模型**，他会保证每次连接可以完成多次连续的请求，减少了重新进行连接的时间。再次之后又增加了**流水线模型**，多次连续的请求甚至不需要等待立即返回就可以被发送，这样就减少了耗费在网络延迟上的时间。

!["HTTP/1.x 的连接管理"]({{site.url}}/assets/images/network/http1.x "HTTP/1.x 的连接管理")

#### 短连接

HTTP/1.0 的默认模型，是短连接。每一个 HTTP 请求都由它自己独立的连接完成；这意味着发起每一个 HTTP 请求之前都会有一次 TCP 握手，而且是连续不断的。

TCP 协议握手本身就是耗费时间的，所以 TCP 可以保持更多的热连接来适应负载。短连接破坏了 TCP 具备的能力，新的冷连接降低了其性能。

这是 HTTP/1.0 的默认模型(如果没有指定 `Connection` 协议头，或者是值被设置为 `close`)。而在 HTTP/1.1 中，只有当 `Connection` 被设置为 `close` 时才会用到这个模型。

#### 长连接

短连接有两个比较大的问题：创建新连接耗费的时间尤为明显，另外 TCP 连接的性能只有在该连接被使用一段时间后(热连接)才能得到改善。为了缓解这些问题，*长连接* 的概念便被设计出来了，甚至在 HTTP/1.1 之前。或者这被称之为一个 *keep-alive* 连接。

一个长连接会保持一段时间，重复用于发送一系列请求，节省了新建 TCP 连接握手的时间，还可以利用 TCP 的性能增强能力。当然这个连接也不会一直保留着：连接在空闲一段时间后会被关闭(服务器可以使用 `Keep-Alive` 协议头来指定一个最小的连接保持时间)。

长连接也还是有缺点的；就算是在空闲状态，它还是会消耗服务器资源，而且在重负载时，还有可能遭受 DoS attacks 攻击。这种场景下，可以使用非长连接，即尽快关闭那些空闲的连接，也能对性能有所提升。

HTTP/1.0 里默认并不使用长连接。把 `Connection` 设置成 close 以外的其它参数都可以让其保持长连接，通常会设置为 retry-after。

在 HTTP/1.1 里，默认就是长连接的，协议头都不用再去声明它(但我们还是会把它加上，万一某个时候因为某种原因要退回到 HTTP/1.0 呢)。

<br/>

### HTTP/2 帧
在 HTTP/1.x 报文有一些性能上的缺点：
- Header不会被压缩。
- 两个报文之间的header通常相似，但仍然需要重复传输。
- 无法复用。

HTTP/2 添加了一个步骤，将HTTP/1.x消息分为帧并嵌入到流（stream）中。数据帧和报头帧分离，这将允许报头压缩。将多个流组合，该过程称为 *多路复用（multiplexing）*。 

!["HTTP/2 帧"]({{site.url}}/assets/images/network/Binary_framing.png "HTTP/2 帧")

<br/>

### HTTP 缓存
缓存是一种保存资源副本，下次请求时直接使用该副本的技术。当web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。缓存的好处在于缓解服务器端的压力，提升性能。

缓存的种类大致分为两类：私有和共享缓存。


#### （私有）浏览器缓存
私有缓存只能用于单独的用户。在浏览器设置中的“缓存”选项，浏览器缓存拥有用户通过 HTTP 下载的所有文档。这些缓存为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余的请求。它同样可以提供缓存内容的离线浏览。

#### （共享）代理缓存
共享缓存可以被多个用户使用。例如，ISP或你所在的公司可能会架设一个web代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复使用，减少网络拥堵与延迟。

<br/>

### 缓存操作的目标
常见的 HTTP缓存 只能存储 `GET` 响应。缓存的关键主要包括请求方法和目标 URI （一般只能 `GET` 请求才能被缓存）。例如:

- 一个检索请求的成功响应: 对于 `GET` 请求，响应状态码为：`200`，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应。
- 永久重定向: 响应状态码：`301`。
- 错误响应: 响应状态码：`404` 的一个页面。
- 不完全的响应: 响应状态码 `206`，只返回局部的信息。

除了 `GET` 请求外，如果匹配到作为一个已被定义的cache键名的响应

<br/>

### 缓存控制
HTTP/1.1 定义的 `Cache-control` 头用来区分对缓存机制的支持情况，请求头和响应头都支持这个属性，通过它来定义缓存策略。

<br/>

#### 禁止缓存

缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。

```
Cache-Control: no-store
```

<br/>

#### 强制确认缓存

如下头部定义，此方式下，每次有请求发出时，缓存会将此请求发到服务器（该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（注：返回 `304` ），则缓存才使用本地缓存副本。

```
Cache-Control: no-cache
```

<br/>

#### 私有和公共

"public" 指令表示该响应可以被任何中间代理、CDN等缓存。若指定了"public"，则一些通常不被中间人缓存的页面（因为默认是private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定状态码的页面），将会被其缓存。

而 "private" 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。

```
Cache-Control: private
Cache-Control: public
```

<br/>

#### 缓存过期机制

过期机制中，最重要的指令是 "max-age=<seconds>"，表示资源能够被缓存（保持新鲜）的最大时间。相对Expires而言，max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。

```
Cache-Control: max-age=31536000
```

<br/>

#### 缓存验证确认

当使用了 `must-revalidate` 指令，那就意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓存将不被使用。详情看下文关于缓存校验的内容。

```
Cache-Control: must-revalidate
```

<br/>

### 缓存处理的过程图示

!["缓存流程图"]({{site.url}}/assets/images/network/HTTPStaleness.png "缓存过程图示")

<br/>

### HTTPS
HTTPS （Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 *SSL/TLS* 来加密数据包。HTTPS 开发的主要目的，是提供对网络服务器的身份认证，保护交换数据的隐私和完整性（如银行卡号、密码等支付信息数据）。

#### 工作流程
- TCP 三次握手
- 客户端验证服务器数字证书
- DH 算法协商对称加密算法的密钥、hash算法 的密钥
- SSL 安全加密隧道协商完成
- 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的 hash算法 进行数据完整性保护，保证数据不被篡改。

#### HTTPS 和 HTTP 的区别
- *工作层*：HTTP 工作在应用层，而 HTTPS 工作在传输层。
- *连接端口*：HTTP 端口号是80，而 HTTPS 端口号是443。
- *传输方式*：HTTP 是超文本传输协议，信息是明文传输，而 HTTPS 是 SSL 加密传输协议。
- *工作耗时*：HTTP耗时 = TCP握手，HTTPS耗时 = TCP握手 + SSL握手。
- *显示形式*：HTTP 的URL以 `http://` 开头，而HTTPS的URL以 `https://` 开头。
- *费用*：HTTP 无需费用，而 HTTPS 需要到 CA 申请证书，一般免费证书较少，需要一定费用。
- *安全性*：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL + HTTP协议 构建的可进行加密传输、身份认证的网络协议，比 HTTP协议 安全。

****

<br/>

# 传输层
传输层是 TCP/IP协议 中第三层，也是整个网络体系结构中的关键层次之一，主要负责向两个主机中进程之间的通信提供服务，由于一个主机同时运行多个进程，因此传输层具有复用和分用功能。传输层中最为常见的两个协议分别是传输控制协议 `TCP` 和用户数据报协议 `UDP`。传输层提供逻辑连接的建立、传输层寻址、数据传输等功能。

<br/>

**传输层的作用**
- 传输层为相互通信的应用程序提供了逻辑通信
- 传输层还要对收到的报文进行差错检测
- 传输层提供了面向连接和无连接的两种服务

## 传输层的端口号
在 TCP/IP协议 中的端口，是指的逻辑意义上的端口。而端口号，则是每一个端口上的标记。一台拥有 IP地址 的主机可以提供很多服务（如 Web 服务），这些服务都可以由一个 IP地址 完成。而对于每一个服务，需要通过 `IP地址 + 端口号` 进行区分。

<br/>

端口号的范围是从 1～65535 。其中 1~1024 是被RFC 3232 规定好了的，被称作公认端口（Well Known Ports）；而从 1025~65536 的端口被称为动态端口 (Dynamic Ports)，用于建立与其他主机的会话或其他用途。 

### 常见端口号

| 网络服务 | 端口号 | 协议 |
|-----|-----|------|
| FTP数据 | 20 | TCP |
| FTP控制 | 20 | TCP |
| SSH | 22 | TCP |
| Telnet | 23 | TCP |
| SMTP | 25 | TCP |
| DNS | 53 | UDP |
| DHCP | 67 | UDP |
| TFCP | 69 | UDP |
| HTTP | 80 | TCP |
| POP3 | 110 | TCP |
| HTTPS | 443 | TCP |
| SOCKS | 1080 | TCP |

| 应用层服务 | 端口号 |
|---------|-----|
| MYSQL | 3306 |
| Mongodb | 27017 |
| Tomcat | 8080 |


## UDP 协议

UDP（User Datagram Protocol，用户数据报协议），被定义是在一组互联的计算机网络环境下的一个数据包交换模式。是一个*无连接协议*，传输数据之前源端和终端都不建立连接。

UDP协议 提供了一个过程为应用程序去发送消息给另一个应用程序在最小的协议机制。

它是面向报文，但它没有办法保证消息传递的完整性，也无法对破坏的报进行重发。

因此对于 UDP协议 的应用通常在：音视频，网络视频会议等需要保证*实时性*的应用程序下。

### UDP 报文格式
!["udp报文格式"]({{site.url}}/assets/images/network/udp_message_format.png "udp报文格式")

- 源端口（Source port）：源端口是一个可选的参数，它指示着发送方的端口。并且可以假定为在没有任何其他信息的情况下应将答复寻址到的端口。如果不存在就插入 `0`。
- 目的端口（Destination port）：目的端口指传输网络目标地址的端口号。
- 报文长度（Length）：数据报的长度，包括header以及data。
- 校验和（Checksum）：UDP协议 使用报文中的校验和来保证数据的安全。实际上收到的数据都是经过校验的，不会有传错的情况，但无法保证丢包或者是乱序的可能。

<br/>

### UDP 特点
- UDP 是一个 *非连接* 的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP 把每个消息段放在队列中，应用程序每次从队列中读一个消息段。

- 由于传输数据 *不建立连接*，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。

- UDP 信息包的标题很短，只有 *8个字节*，相对于 TCP 的20个字节信息包的额外开销很小。

- 吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。

- UDP使用尽最大努力交付，即 *不保证可靠交付*，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。

- UDP 是 *面向报文* 的。发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。

<br/>

### UDP实现可靠传输

（待补充）

## TCP 协议 🌟

TCP（Transmission Control Protocol， 传输控制协议）协议是 *面向连接* 的协议，即在传输数据之前，发送端和接收端建立逻辑连接。目的是为了主机到主机之间数据传输的可靠连接。

在发送方和接收方的通信基于 *字节流* 的方式，*全双工* 数据通信，在传输数据之前发送端和接收端要进行 *握手* 去建立连接，还包括 *流量控制* 保证数据可靠传输。

### TCP 报文格式

!["TCP报文格式"]({{url.site}}/assets/images/network/tcp_message_format.jpg "tcp_message_format")

从上图可以看出，TCP 的报文格式比 UDP 复杂很多，下面是对各个段位的说明：
- 源端口号（source port number）：占 2 字节或者 16 比特，它指示着发送方的端口。

- 目的端口号（destination port number）：占 2 字节或者 16 比特，它指示着接收方的端口。

- 序列号（sequence number）：占 4 字节或者 32 比特，TCP 连接中传输的数据流中的每一个字节都有一个序号，序号字段的值指的是当前报文所发送的数据第一个字节的序号。

- 确认号（acknowledgement number）：占 4 字节或者 32 比特，TCP 连接中传输数据时，期待收到的下一个字节的序号。

- 数据偏移（data offset）：占 4 位，表示 TCP 头的长度。

- 保留（reserved）：占 6 位，TCP 头中保留数据始终为 0。

- 控制标志（control flags）：占 6 位，TCP 中有 6 个标准的标志，每一个分别占一位如果需要进行标记则将对应位等于 `1`，分别为：
  - URG：表明紧急指针（urgent pointer）字段有效，表明数据中有紧急数据，应尽快传送
  - ACK：表示确认号（acknowledgement number）字段有效
  - PSH：接收者应尽快将此数据传递给应用程序
  - RST：表示 TCP 连接中出现了错误，必须释放连接，在重新连接
  - SYN：表示这是一个连接请求或连接接受报文
  - FIN：表示释放连接

- 窗口大小（window size）：占 2 字节或者 16 比特，这是接收方能够接受的字节数，限制窗口为 65535 字节。

- 校验和（checksum）：占 2 字节或者 16 比特，检验和字段检验的范围包括首部和数据这两部分，这是必填字段，必须由发送方计算并存储，然后由接收方进行验证。它是通过在TCP段之前添加一个伪头来计算的，它由三个32位字组成，其中包含源IP地址和目标IP地址，一个字节设置为0，一个字节设置为6（IP中TCP的协议号） 数据报标题）和段长度（以字为单位）。

- 紧急指针（urgent pointer）：占 2 字节或者 16 比特，指本报文段中紧急数据共有多少个字节（紧急数据放在本报文段的最前面）。

<br/>

### TCP 建立连接

TCP 建立连接也就是 **TCP 三次握手** 的过程。是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的 *序列号（sequence number）* 和 *确认号（acknowledgement number）* 并交换 *TCP窗口大小* 信息。过程如下图：

 !["tcp三次握手过程"]({{url.site}}/assets/images/network/tcp_three_way_handshake.png "tcp_three_way_handshake")

<br/>

**1. 第一次握手：** 客户端发送一个 `SYN = 1` 的 TCP 报文段，指明客户端准备连接服务器端口，以及初始 *序列号(sequence number)* 为 `x`，保存在 TCP 报文的 *序列号（sequence number）* 字段里。然后客户端进入 `SYN_SEND` 的状态，等待服务器的确认。

!["第一次握手"]({{url.site}}/assets/images/network/first_step_of_three_handshake.png "first_step_of_three_handshake")

<br/>

**2. 第二次握手：** 服务器发回带有 `SYN = 1` 以及 `ACK = 1` 的应答。将 *确认号（acknowledgement number）* 设置为 `x + 1`。*序列号（sequence number）* 为 `y`，此时服务器进入 `SYN_RECV` 状态。

!["第二次握手"]({{url.site}}/assets/images/network/second_step_of_three_handshake.png "第二次握手")

<br/>

**3. 第三次握手：** 客户端再次发送 `ACK = 1` 但 `SYN = 0` 的应答。同样*确认号（acknowledgement number）* 设置为`y + 1`。*序列号（sequence number）* 为 `x + 1`，发送给服务器端。客户端和服务器都进入 `ESTABLISHED` 状态，完成 TCP 三次握手。

!["第三次握手"]({{url.site}}/assets/images/network/third_step_of_three_handshake.png "第三次握手")

<br/>

### 为什么需要三次握手

“三次握手”的目的是为了 **防止已失效的连接请求报文段突然又传送到服务器**，因而产生的错误。已失效的连接请求报文段可能会出现这样的情况：

客户端突然发出的第一个连接请求报文段并没有丢失，而是在某个网络节点长时间的滞留了，以致延误到连接释放以后的某个时间才到达服务器。本来这是一个早已失效的报文段，但服务器收到此失效的连接请求报文段后，就误以为是客户端再次发出的新的连接请求。于是就向客户端发送确认报文段，同意建立连接，假设不采用 “三次握手”，那么只要服务器发出确认，新的连接就建立了。由于现在客户端并没有发出建立连接的请求，因此不会理睬服务器的确认，也不会向服务器发送数据。但服务器却以为新的连接已经建立，并一直等待客户端发来数据。这样 **服务器的很多资源就白白浪费**。

采用 “三次握手” 的办法可以防止上述现象发生，如同上述的情况，客户端不会向服务器的确认应答发出确认信息。服务器由于收不到确认，就知道客户端并没有要求建立连接。

<br/>

### TCP 关闭连接

TCP 关闭连接需要发送四个包，因此称为 **TCP 四次挥手**。客户端和服务器均可主动发起挥手动作。

!["tcp四次挥手过程"]({{url.site}}/assets/images/network/tcp_four_way_wavehand.png "tcp_four_way_wavehand")

<br/>

**1. 第一次挥手：** 客户端向服务器（或者服务器向客户端）发送一个 `FIN = 1`， *序列号（sequence number)* 为 `u` 的 TCP 报文段。此时客户端进入 `FIN_WAIT_1` 的状态，标识客户端没有数据要发送给服务器了，请求关闭连接。

<br/>

**2. 第二次挥手：** 服务器向客户端发送一个 `ACK = 1`，以及 *确认号（sequence number）* 为 `u + 1`，*序列号（sequence number）* 为 `v` 的 TCP 报文段。此时服务器进入 `CLOSE-WAIT` 状态，客户端进入 `FIN-WAIT-2` 状态。

<br/>

**3. 第三次挥手：** 服务器会观察自己是否还有数据没有发送给客户端，如果有，先把数据发送给客户端，再发送一个 `FIN = 1` 以及 `ACK = 1`。*序列号（sequence number）* 为 `w`，*确认号（acknowledgement number）* 为 `u + 1` 的 TCP 报文段。如果没有，那么服务器直接发送 `FIN = 1` 的报文段给客户端。请求关闭连接，此时服务器进入 `LAST_ACK` 状态。

<br/>

**4. 第四次挥手：** 客户端收到服务器发送的 `FIN = 1` 的报文段后，向服务器发送确认报文段，即 `ACK = 1`。*序列号（sequence number）* 为 `u + 1`，*确认号（acknowledgement number）* 为 `w + 1` 的 TCP 报文以后，就可以关闭连接了；此时，客户端需要 **等待2MSL** `TIME-WAIT` 状态后依然没有回复，则证明服务器已正常关闭，客户端也可以关闭连接。

<br/>

> 为什么需要四次握手，为什么不是三次？
因为在建立连接时，当服务器收到客户端的 `SYN` 连接请求报文后，可以直接发送 `SYN = 1, ACK = 1`的报文。其实 `ACK` 报文是用来应答的，`SYN` 报文是用来同步的。但是关闭连接时，当服务器收到 `FIN` 报文时，很可能并不会立即关闭 `socket`，所以只能先回复一个 `ACK` 报文，同时客户端接收到 `FIN`，等到服务器把所有的报文都发送完毕后，服务器通知客户端发送 `FIN` 报文，所以需要四次挥手。

<br/>

#### TIME-WAIT

`TIME-WAIT` 为主动关闭连接时对于复杂的网络状态，TCP 的实现提出的一种应对措施，为了应对其中一种异常状态。

为了理解 `TIME-WAIT` 状态的必要性，先来假设有这样一种情况，以 A 和 B 表示 TCP 的连接两端，A 为主动关闭的一端。

1. 在四次挥手中，A 发 `FIN`，B 应答 `ACk`，B 再发 `FIN`，A 响应 `ACK` 实现连接的关闭。而如果 A 响应的 `ACK` 包丢失，B 会以为 A 没有收到自己的关闭请求，然后会重试向 A 再发 `FIN` 包。

如果没有 `TIME-WAIT` 状态，A 不再保护这个连接的信息，收到一个不存在的连接的包，A 会响应 `RST` 包，导致 B 端异常响应。

此时，`TIME-WAIT` 是为了保证 **全双工的TCP连接正常终止**。

2. TCP 下的 IP 层协议时无法保证包传输的先后顺序的，如果双方挥手之后，一个网络四元组（src/dst/ip/port）被回收，而此时网络中还有一个迟到的数据包没有被 B 接收，A 立刻使用了同样的四元组再建立了一个新的连接后，这个迟到的数据包才到达 B，那么这个数据包就会让 B 以为是 A 刚刚发过来的。

此时，`TIME-WAIT` 是为了保证 **网络中迷失的数据包正常过期**。

<br/>

**TIME_WAIT存在的理由：**

- 尽可能护送最后的 `ACK` 达到对端(使用 RRT 可能不够，因此用 2MSL)
- 新旧四元组互不干扰(关闭连接后，在没有所有网络包都消失时，新旧四元组完全一致可能会导致混乱)

<br/>

### TCP 流量控制

如何保证 TCP 的可靠传输，这其中有一个关键的部分就是 **TCP 的流量控制**。流量控制的目的是，如果发送方发送数据过快，接收方来不及接收， 那么就会有分组丢失。为了避免分组丢失控制发送方的发送速度，使得接收方来得及接收。流量控制根本目的是 *防止分组丢失*，它是构成 TCP 可靠传输的一方面。

如何实现流量控制：由 **滑动窗口协议** 实现，滑动窗口协议即保证了 *分组无差错*、*有序接收*，也实现了 *流量控制*。主要的方式就是接收方返回的 ACK 中包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。

!["flow_control"]({{url.site}}/assets/image/network/flow_control.jpg "flow_control")

<br/>

#### 滑动窗口

滑动窗口是在 TCP 中使用，维持发送发和接收方的缓冲区。缓冲区是用来解决网络之间数据不可靠的问题，例如丢包，重复包，出错，乱序。

在 TCP 协议中，发送方和接收方通过各自维护自己的缓冲区。通过商定包的重传机制等一系列操作，来解决不可靠的问题。

1. 如果保证次序：

!["sliding_window_1"]({{url.site}}/assets/images/network/sliding_window_1.jpg "sliding_window_1")

发送方发送一个包1，这时候接收方回复确认包1，接着发送方发送包2，接收方回复确认包2，以此类推下去知道发完所有的包。在这样的情况下吞吐量非常低，发送包1过后必须要等待确认包1的回复，之后才能发送包2。

2. 如何提高吞吐量：

!["sliding_window_2"]({{url.site}}/assets/images/network/sliding_window_2.jpg "sliding_window_2")

如图，发送方将两个发送包通过一起发送，然后一起确认。可以看出改进费方案大大缩短了发送包的时间。接下来，同样有一个问题：如何确认发送包的个数。

3. 如何实现最优解：

step_sliding_window_1

!["step_sliding_window_1"]({{url.site}}/assets/images/network/step_sliding_window_1.png "step_sliding_window_1")

在图中，我们可看出灰色 1、2、3 号包已经发送完毕，并且已经收到了 ACK。而4、5、6、7 号包是黄色的，表示已经发出去但未收到接收方的 ACK 包。8、9、10 号包是绿色的，表示还没有发送，但接下来要发送的包。从 11 到 16 包表示还没读进内存，要等 4-10 号包有动作才会继续往下发送。

!["step_sliding_window_2"]({{url.site}}/assets/images/network/step_sliding_window_2.png "step_sliding_window_2")

**正常情况：**

从上图可以看出 4 号对方已经接收并且回复了 ACK。*窗口* 就往右移动了一格，就把 11 号包读进了缓存，进入了 *待发送* 的状态。同时 8、9 号包变成了黄色，表示已经发送出去了。接下来的操作就是一样的，收到 ACK 后，*窗口* 向右移动读取未发送的包读进缓存，把 *待发送* 状态的包变为 *已发送*。

**丢包情况：**

!["step_sliding_window_3"]({{url.site}}/assets/images/network/step_sliding_window_3.png "step_sliding_window_3")

发生的情况：发送方一直在等待ACK。如果一直等不到的话，发送方也会把读进缓存的包也一起发过去。但是，这时候我们的窗口已经发满了。所以并不能把 12 号包读进来，而是始终在等待 5 号包的 ACK。

**超时重传：**

如果一直等不到ACK，这时候的解决方法为超时重传机制。

- 回退N帧（Go-Back-N）：如果发送方发送或接收到的包有错误发生，那么从那个错误的包开始到之后所有的包全部重新发送。
	特点： 复杂度低，但不必要的包会再次重发，所以效率不是很高。
	 
- 选择性重传（Selective Repeat）：如果发送发发送或接收到的包有错误发生，那么只重新发送那个错误的包。
  特点：复杂度高，但不需要发送没必要的包，所以效率高。

<br/>

### TCP 拥塞控制

****

<br/>

# Wireshark 抓包


