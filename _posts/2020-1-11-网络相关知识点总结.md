---
layout: article
title: 网络相关知识点总结
aside:
  toc: true
key: 
---

# 网络协议
## 网络分层的意义
- 各层之间相互独立，高层是不需要知道底层的功能如何实现的，只需要知道通过与底层的接口就可以获得所需要的服务；
- 灵活性好，各层都可以采用最恰当的技术实现；
- 易于实现和标准化，由于采用了规范的层次结构去组织网络功能与协议，因为可以将计算机网络复杂的通信过程，划分为有序的连续动作与有序的交互过程，有利于将网络复杂的通信工作过程简化为一系列可以控制和实现的功能模块。
<br/>

## 两种网络分层模型
### OSI 模型
即开放系统互连（Open System Interconnection），是网络通信的一种通用框架，分为七层，并且定义了在每一层上数据的处理方式。

![OSI模型七层]({{site.url}}/assets/images/network/image001.gif "OSI模型七层")

- **第七层 -- 应用层（Application）**：针对特定应用的协议
它的作用是为**应用程序提供服务**并规定应用程序中通讯相关的细节，也就是为应用提供服务。常见的协议有HTTP、FTP、TELNET、SMTP等。
  - HTTP：超文本传输协议，提供数据供浏览器使用；
  - FTP：文件传输协议，用来在客户机和FTP服务器之间传输文件；
  - DHCP：动态主机配置协议，DHCP服务器为客户机动态分配IP地址；
  - POP3:邮件接收协议，用于从POP3服务器接收邮件；
  - SMTP：邮件发送协议，用于通过SMTP服务器发送邮件。

- **第六层 -- 表示层（Presentation）**：设备固有数据格式和网络标准数据格式的转换
这层的主要功能是：**转换**、**压缩**和**加密**。它的作用是将应用处理的信息转化为适合网络输出的格式，或者将来自下一层的数据转换为上一层能处理的格式。它主要负责数据格式的转换。具体来说，就是将设备固有的数据格式转换为网络标准格式。常见的协议有ASCII、SSL/TLS等。

- **第五层 -- 会话层（Session）**：建立、管理和维护通信，管理传输层以下的分层
这层的作用就是为**创建**、**管理**和**终止会话**提供必要的方法。这些方法一般以API的形式出现，常用的API有NetBIOS（Network Basic Input/Output Interface，网络基本输入/输出系统）、RPC（Remote Procedure Cell，远程过程调用）和Socket API。可以理解为两个应用程序进程之间的逻辑连接，两个应用程序通过这个逻辑连接在一段时间内交换数据。

- **第四层 -- 传输层（Transprt）**：管理两个节点之间的数据传输（确保数据被可靠地传送给目标地址）
传输层起着**可靠传输**的作用。这里的“传输”指的是**端对端**或者**主机对主机**的传输。只在通信双发节点进行处理，而不需要在路由器上处理。
传输层上最重要的两个协议是**TCP（面向连接的协议，Connection-Oriented）**和**UDP（无连接的协议，Connection-Less）**。

- **第三层 -- 网络层（Network）**：地址管理和路由选择
网络层负责将**数据传输到目标地址**，目标地址可以使用多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择。主要由IP、ICMP两个协议组成。
网络层将数据从发送端的主机发送到接收端的主机，两台主机可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址用的是IP地址，IP地址通过不断转发到更近的IP地址，最终可以到达目标地址。

- **第二层 -- 数据链路层（Data Link）**：互连设备之间传送和识别数据帧
数据链路层负责**物理层面上互连的节点之间的通信传输**。它关心的是如何把**数据发送到本地网络中去**，平时常说的**LAN**技术，如以太网(Ethernet)、令牌环网(Token Ring)、光纤分布数据接口(FDDI)和802.11(WIFI)都定义在这一层。
数据链路层又分为两个子层：**逻辑链路控制层（Logical Link Control）**和**介质访问控制层（Media Access Control）**。
数据链路层有一个重要的概念，即**MAC地址**，可以称为物理地址、硬件地址、以太网地址等。每个网卡（Network Interface Card）都有一个**唯一的MAC地址**，数据链路层通过MAC地址来确保数据能够正确被发送到目标设备。MAC地址有一个**48位二进制整数**，通常的表示方法是用-隔开的6个十六进制整数，如14-FE-B5-B0-2B-96。

- **第一层 -- 物理层（Physical）**：将数据0、1转换为电压和脉冲光传输给屋里的传输介质
物理层位于OSI的底层，所有其他层的数据最终都必须经由物理层才能发送出去。物理层的功能包括：
  - **硬件规范的定义**，如电缆、连接器、无线接收器等的工作方式，网卡、集线器等网络设备也工作在物理层；
  - **编码和信号**，物理层把计算机中的二进制0和1转换成可以在物理介质上传输的信号；
  - 再把数据转换成信号后，物理层负责**信号的实际发送和接收**。
<br/>

### TCP/IP 模型
TCP/IP分层模型被称作因特网分层模型（Internet Layering Model）、因特网参考模型（Internet Reference Model），一共分为四层：

- **第四层 -- 应用层（Application）**：TCP/IP模型的**应用层**相当于OSI模型的**会话层**、**表示层**和**应用层**，常用协议FTP(文件传输协议)、DNS(域名系统)、HTTP协议、Telnet(网络远程访问协议)。

- **第三层 -- 传输层（Transport）**：提供**TCP**和**UDP**两个协议，主要功能是**数据格式化**、**数据确认**和**丢失重传**等。

- **第二层 -- 网络层（Network）**：该层负责**相同和不同网络中计算机之间的通信**，主要处理**数据包**和**路由**。数据包是网络传输的最小数据单位，通过某条传输路线将数据包传给对方，如IP协议、ICMP协议、IGMP协议。在IP层中，**ARP协议**用于将**IP地址转换为物理地址**，**ICMP协议**用于**报告差错**和**传送控制信息**，**IP协议**在TCP/IP协议组中处于核心地位。

- **第一层 -- 网络接口层（Network Interface）**：该层对实际的**网络媒介的管理**，包括操作系统中的设备驱动程序和计算机相对的网络接口卡。
<br/>

### OSI模型和TCP/IP模型的相同点
- 都是采用协议分层的方法；
- 层次协议的功能大体相同；
- 两种模型都可以解决异构网的互连；
- 都是计算机通信的国际标准，OSI原则上是国际通用，TCP/IP工业上使用较多；
- 都提供TCP和UDP；
- 都是基于一种协议集的概念，协议集是一组完成特定功能的相互独立的协议。
<br/>

### OSI模型和TCP/IP模型的差异
- TCP/IP一开始就考虑到多种异构网的互连问题，并将网际协议IP作为TCP/IP的重要组成部分。ISO和CCITT最初只考虑到全世界都使用一种统一的标准公用数据网将各种不同的系统互连在一起，后来，ISO意识到网际协议IP的重要性，然而已经来不及了，只好在网络层划分一个子层来完成类似TCP/IP中的IP的作用。

- TCP/IP一开始就对面对连接服务和无连接服务并重，而OSI在开始的时只强调面向连接这一种服务。OSI之后才开始制定另一种无连接服务的有关标准。

- TCP/IP较早就有很好的网络管理功能，而OSI到后来才考虑这个问题。

- TCP/IP的不足：TCP/IP模型对“服务”，“协议”和“接口”等概念没有很清楚的区分开，TCP/IP模型的通用性比较差。很难用来描述其他种类的协议栈，TCP/IP的网络接口严格来说并不是一个层次而仅仅是一个接口。

# TCP/IP 协议
在`TCP/IP`协议中，不同协议层对包都进行了封装：
- 从用户的数据报文进过封装传递给传输层；
- 传输层封装TCP首部，上一层传递过来的数据为TCP数据，传递给网络层；
- 网络层封装IP首部，上一层传递过来的数据为IP数据，传递给数据链路层；数据链路层封装帧首部；
- 帧数据是最终在物理网络上传输字节序列。

过长的IP报文段可能会被分包传输。拆包的过程则是当帧数据到达时，沿着协议栈从底自上的进行拆解。

数据从上到下封装的格式为：`比特（bit） -> 帧（frame） -> 包（packet） -> 段（segment） -> 数据（data）`。

!["tcp/ip的数据封包与拆解"]({{site.url}}/assets/images/network/image002.png "tcp/ip的数据封包与拆解")

下面的内容将从TCP/IP模型的应用层到网络接口层，进行详解。

# 应用层
应用层为`tcp/ip协议`的最上层，也就是我们开发的应用程序，位于这一层。在这一层包含一些协议，比如：`DNS(域名解析协议)`、`SMTP(简单邮件传输协议)`、`FTP(文件传输协议)`、`HTTP(超文本传输协议)`、`Telnet(网络远程协议)`等。

## DNS 域名解析协议
### 域名注册
- **domain name 域名**
域名是一个访问网站或者是应用程序的名字，例如，当用户在浏览器上输入的`www.example.com`。为了是你的网站或者是应用程序在互联网上可用，就必须注册一个域名。
<br/>

- **domain registrar 域注册商**
域注册商是一个公司经ICANN（互联网名称和数字地址分配机构）认可的公司，可以处理特定顶级域名（TLD）的域名注册。例如，Amazon Registrar, Inc. 是一个域名注册商对于`.com`、`.net`、`.org`。
<br/>

- **domain registry 域注册局**
域注册局是一个公司有权利去销售一些特定的顶级域名（TLD）。域注册表定义了用于注册域的规则，例如地理TLD的居住要求。 域注册中心还维护具有相同TLD的所有域名的权威数据库。 注册表的数据库包含每个域的信息，例如联系信息和名称服务器。
<br/>

- **domain reseller 域代理商**
域代理商是一个公司为注册服务商出售域名。
<br/>

- **top-level domain (TLD) 顶级域名**
顶级域名是域名的最后一部分，例如`.com`、`.net`、`.org`。
<br/>

### DNS 域名解析协议概念
- **A 记录**
A记录，又称主机记录，是将一个域名解析成一个IP地址。当访问一个域名时DNS会通过A记录解析出相对应的IP地址，以达到后续访问的目的。
<br/>

- **CNAME 记录**
CNAME记录，又称别名记录，是将一个域名，映射到另外一个域名。这两个别名的全称就`http://www.mydomain.com/`和`mail.mydomain.com`。实际上他们都指向 `host.mydomain.com`。
<br/>

- **DNS 解析**
DNS解析的过程就是寻找那台机器上有你需要的资源的过程。当在浏览器上输入一个地址时，其实并不是输入的网站真正意义上的地址。互联网上每台计算机的唯一标识是它的IP地址，但IP地址并不方便记忆。用户更喜欢用方便记忆的网站去寻找互联网上的其它计算机，也就是用户输入在浏览器上的网站。一个网站到IP地址的转换，这个过程就是DNS解析。查找顺序：`浏览器缓存 -> 操作系统缓存 -> 本地host文件 -> 路由器缓存 -> ISP DNS缓存 -> 顶级DNS服务器`。
  - **浏览器缓存**：首先会向浏览器的缓存中读取上一次访问的记录；
  - **操作系统缓存**：查找存储在系统运行内存中的缓存；
  - **host文件**：查看本地硬盘的host文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用host文件里面的ip地址；
  - **路由器缓存**：有些路由器也有DNS缓存的功能，访问过的域名会存在路由器上；
  - **ISP DNS缓存**：互联网服务提供商也会提供DNS服务。在本地查找不到的情况下，就会向ISP进行查询，ISP会在当前服务器的缓存内查找是否有记录，如果有，则返回这个IP，若没有，则会开始向顶级域名服务器请求查询。
  - **顶级DNS服务器**：根域名收到请求后，会判别这个域名(.com)是授权给那台服务器管理，并返回这个顶级DNS服务器的IP。请求者收到这台顶级DNS的服务器IP后，会向该服务器发起查询，如果该服务器无法解析，该服务器就会返回下一季的DNS服务器IP，本机继续查找，直到服务器找到主机。
<br/>

### dig 命令
通过`dig`命令查询主机地址的信息：
!["dig www.baidu.com"]({{site.url}}/assets/images/network/image003.png "dig www.baidu.com信息")
- `dig`命令的版本以及输入参数的信息
```
; <<>> DiG 9.10.6 <<>> www.baidu.com
;; global options: +cmd
```
- `dig`命令返回的DNS解析的技术信息
```
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 13539
;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1
```
- 查询的域名信息
```
;; QUESTION SECTION:
;www.baidu.com.			IN	A
```
- `dig`查询到的结果，其中A为A记录，CNAME为CNAME记录
```
;; ANSWER SECTION:
www.baidu.com.		182	IN	CNAME	www.a.shifen.com.
www.a.shifen.com.	151	IN	A	163.177.151.110
www.a.shifen.com.	151	IN	A	163.177.151.109
```
- 剩余数据记录
```
;; Query time: 12 msec
;; SERVER: 120.80.88.88#53(120.80.88.88)
;; WHEN: Mon Jan 13 18:15:10 CST 2020
;; MSG SIZE  rcvd: 101
```
<br/>

## HTTP 协议
**HTTP（超文本传输协议）** 是一个用于传输超媒体文档（例如HTML）的应用层协议。它是为Web浏览器与Web服务器之间的通信而设计的，但也可以用于其他目的。HTTP 遵循经典的**CS（客户端-服务器端）模型**，客户端打开一个连接以发送请求，然后等待它收到服务器端响应。HTTP 是**无状态协议**，这意味着服务器不会再两个请求之间保留任何数据（状态）。该协议虽然通常基于**TCP/IP层**，但可以在任何可靠的传输层上使用；也就是说，不像UDP，它是一个不会静默丢失消息的协议。RUDP-作为UDP的可靠化升级版本-是一个合适的替代选择。
<br/>

### HTTP 的基本性质
- **HTTP 是简单的**：虽然下一代`HTTP/2`协议将HTTP消息封装到了帧（frames）中，HTTP大体上还是被设计得简单易读；
<br/>

- **HTTP 是可拓展的**：在`HTTP/1.0`中出现的`HTTP headers`让协议扩展变得非常容易。只要服务端和客户端就新`headers`达成语义一致，新功能就可以被轻松加入进来。
<br/>

- **HTTP是无状态，有会话的**：无状态表示在同一个连接中，两个执行成功的请求之间是没关系的。这就会出现一个问题，用户没有办法在同一个网站进行连续交互，比如在一个电商网站里，用户把商品添加入购物车，当切换页面再次添加商品，这两次添加商品之间没有关系，浏览器无法知道用户最终选择了哪些商品。而可以使用`HTTP Cookies`，使得每次请求都能共享相同的上下文信息，达成相同的状态。
<br/>

- **HTTP 和连接**：一个连接是由**传输层**来控制的，这从根本上不属于HTTP的范围。HTTP并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。在互联网中，有两个最常用的传输层协议：TCP是可靠的，而UDP不是。因此，HTTP依赖于面向连接的TCP进行消息传递，但连接并不是必须的。
<br/>

### HTTP 消息
HTTP消息是服务器和客户端之间交换数据的方式。有两种类型的消息：请求（request）—— 客户端发送消息给服务器；响应（response）—— 来自服务器的应答。

HTTP 请求和响应具有相似的结构，由以下部分组成：
- 一行起始行用于描述要执行的请求，或者是对应的状态，成功或失败。这个起始行总是单行的。
- 一个可选的 HTTP 头集合指明请求或描述消息征文。
- 一个空行指示所有关于请求的元数据已经发送完毕。
- 一个可选的包含请求相关数据的正文（比如HTML表单），或者响应相关的文档。正文的大小有起始行的HTTP头来指定。

### HTTP 请求结构
1. **起始行**：HTTP请求是由客户端发出的消息，用来使服务器执行动作。*起始行（start-line）*包含三个元素：
`POST / HTTP 1.1`
`GET /background.png HTTP/1.0`
`HEAD /test.html?query=alibaba HTTP/1.1`
`OPTIONS /anypage.html HTTP/1.0`
`GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1`
- 一个 *HTTP方法（HTTP method）*，例如`GET`、`PUT`和`HEAD`，描述要执行的动作。
- *请求目标（request target）*，通常是一个`URL`，或者是协议、端口和域名的绝对路径，通常以请求的环境为特征。请求的格式因不同的HTTP 方法而异。可以是：
  - 一个绝对路径，末尾跟上'?'和查询字符串；
  - 一个完整的URL，被称为*绝对形式（absolute form）*；
  - 由域名和可选端口（以`:`为前缀）组成的 URL 的authority component。仅在使用`CONNECT`建立HTTP隧道时才使用。
  `CONNECT developer.mozilla.org:80 HTTP/1.1`
  - *星号形式（asterisk form）*，一个简单的的星号(`*`)，配合`OPTIONS`方法使用，代表整个服务器。
  `OPTION * HTTP/1.1`
- *HTTP 版本（HTTP version）*，定义了剩余报文的结构，作为对期望的响应版本的指示符。
<br/>

2. **Headers**：来自请求的 HTTP headers 遵循和 HTTP header 相同的基本结构：不区分大小写的字符串，紧跟着的冒号(`:`)和一个结构取决于 header 的值。整个 header（包括值）由一行组成，这一行可以相当长。
   - *General headers*，例如`Via`，适用于整个报文；
   - *Request headers*，例如`User-Agent`、`Accept-Type`，通过进一步的定义，或者给定上下文(例如`Referer`)，或者进行有条件的限制 (例如`If-None`) 来修改请求。
   - *Entity headers*，例如`Content-Length`，适用于请求的 body。显然，如果请求中没有任何 body，则不会发送这样的头文件。
!["http request headers"]({{site.url}}/assets/images/network/HTTP_Request_Headers2.png "http request headers")
<br/>

3. **Body**：请求的最后一部分是它的body。不是所有的请求都有一个 body：例如获取资源的请求，`GET`，`HEAD`，`DELETE` 和 `OPTIONS`，通常它们不需要 body。 有些请求将数据发送到服务器以便更新数据：常见的的情况是 `POST` 请求（包含 HTML 表单数据）。Body 大致分为两类：
- *Single-resource bodies*，由一个单文件组成。该类型 body 由两个 header 定义： `Content-Type` 和 `Content-Length`.
- *Multiple-resource bodies*，由多部分 body 组成，每一部分包含不同的信息位。通常是和 `HTML Forms` 连系在一起。
<br/>

### HTTP 响应结构
1. **状态行**：HTTP 响应的起始行被称作 *状态行（status line）*，包含以下信息：
`HTTP/1.1 404 Not Found`
- *协议版本*，通常为 `HTTP/1.1`。
- *状态码（status code）*，表明请求是成功或失败。常见的状态码是 `200`，`404`。
- *状态文本（status text）*。一个简短的，纯粹的信息，通过状态码的文本描述，帮助人们理解该 HTTP 消息。
<br/>

2. **Headers**：响应的 HTTP headers 遵循和任何其它 header 相同的结构：不区分大小写的字符串，紧跟着的冒号 (`:`) 和一个结构取决于 header 类型的值。 整个 header（包括其值）表现为单行形式。响应头可分为：
- *General headers*，例如`Via`，适用于整个报文。
- *Response headers*，例如`Vary`和`Accept-Ranges`，提供其它不符合状态行的关于服务器的信息。
- *Entity headers*，例如`Content-Length`，适用于请求的 body。显然，如果请求中没有任何 body，则不会发送这样的头文件。
!["http response headers"]({{site.url}}/assets/images/network/HTTP_Response_Headers2.png "http response headers")
<br/>

3. **Body**：响应的最后一部分是 body。不是所有的响应都有 body：具有状态码 (如`201`或`204`) 的响应，通常不会有 body。
Body 大致可分为：
- *Single-resource bodies*，由已知长度的单个文件组成。该类型 body 由两个 header 定义`Content-Type`和`Content-Length`。
- *Single-resource bodies*，由**未知**长度的单个文件组成，通过将`Transfer-Encoding`设置为 chunked 来使用 chunks 编码。
- *Multiple-resource bodies*，由多部分 body 组成，每部分包含不同的信息段。但这是比较少见的。
<br/>

********

# Wireshark 抓包


