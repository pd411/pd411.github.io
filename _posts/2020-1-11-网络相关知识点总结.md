---
layout: article
title: 网络相关知识点总结
aside:
  toc: true
key: Android
---

1. 为什么要对网络分层，有哪些层
1网络分层的意义：
· 各层之间相互独立，高层是不需要知道底层的功能是如何实现的，只需要知道通过与底层的接口就可以获得所需要的服务
· 灵活性好，各层都可以采用最恰当的技术来实现
· 易于实现和标准化，由于采用了规范的层次结构去组织网络功能与协议，因为可以将计算机网络复杂的通信过程，划分为有序的连续动作与有序的交互过程，有利于将网络复杂的通信工作过程化简为一系列可以控制和实现的功能模块
 
目前存在的两种网络分层模型：OSI模型和TCP/IP模型
2OSI模型：即开放系统互连(Open System Interconnection),是网络通信的一种通用框架，一共分为七层，并且定义了在每一层上数据的处理方法。

 
(1)第七层——应用层(Application)：针对特定应用的协议
它的作用是为应用程序提供服务并规定应用程序中通讯相关的细节，也就是为应用提供服务。常见的协议有HTTP、FTP、TELNET、SMTP等。
· HTTP：超文本传输协议，提供数据供浏览器使用
· FTP：文件传输协议，用来在客户机和FTP服务器之间传输文件
· DHCP：动态主机配置协议，DHCP服务器为客户机动态分配IP地址
· POP3：邮件接收协议，用于从POP3服务器接收邮件
· SMTP：邮件发送协议，用户通过SMTP服务器发送邮件
 
(2)第六层——表示层(Presentation)：设备固有数据格式和网络标准数据格式的转换
这层的主要功能：转换、压缩和加密。它的作用是将应用处理的信息转换为适合网络输出的格式，或者将来自下一层的数据转换为上层能处理的格式。它主要负责数据格式的转换。具体来说，就是讲设备固有的数据格式转换为网络标准格式。常见的协议有ASCII、SSL/TLS等。
 
(3)第五层——会话层(Session):建立、管理和维护通信，管理传输层以下的分层
这层的作用就是为创建、管理和终止会话提供必要的方法。这些方法一般以API的形式出现，常用的API有NetBIOS(Network Basic Input/Output Interface, 网络基本输入/输出系统)、RPC(Remote Procedure Call, 远程过程调用)和Socket API。可以理解为两个应用程序进程之间的逻辑连接，两个应用程序通过这个逻辑连接在一段时间内交换数据。
 
(4)第四层——传输层(Transport):管理两个节点之间的数据传输（确保数据被可靠地传送给目标地址）
传输层起着可靠传输的作用。这里的“传输”指的是端对端或者主机对主机的传输。只在通信双发节点进行处理，而不需要在路由器上处理。
 
传输层上最重要的两个协议是TCP和UCP。TCP是面向连接的协议(Connection-Oriented)，UDP是无连接的协议(Connection-Less)。
 
后面会详细说明
 
(5)第三层——网络层(Network):地址管理与路由选择
网络层负责将数据传输到目标地址，目标地址可以使用多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择。主要由IP、ICMP两个协议组成。
 
网络层讲数据从发送端的主机发送到接受端的主机，两台主机可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址是用的是IP地址，IP地址通过不段转发到更近的IP地址，最终可以到达目标地址。
 
(6)第二层——数据链路层(Data Link):互连设备之间传送和识别数据帧
数据链路层负责物理层面上互连的节点之间的通信传输。它关心的是如何把数据发送到本地网络中去，平时常说的LAN(Local Area Network, 局域网)技术，如以太网(Ethernet)、令牌环网(Token Ring)、光纤分布数据接口(FDDI)和802.11(WIFI)都定义在这一层。
 
数据链路层又分为两个字层:逻辑链路控制层(Logical Link Control)和介质访问控制层(Media Access Control)。
 
数据链路层有一个重要的概念，即MAC地址，可以称为物理地址、硬件地址、以太网地址等。每个网卡(Network Interface Card)都有一个唯一的MAC地址，数据链路层通过MAC地址来确保数据能够正确被发送到目标设备。MAC地址有一个48位二进制整数，通常的表示方法是用-隔开的6个十六进制整数，如14-FE-B5-B0-2B-96。
 
(7)第一层——物理层(Physical):将数据的0、1转换为电压和脉冲光传输给物理的传输介质
物理层位于OSI的底层，所有其它层的数据最终都必须经由物理层才能发送出去。物理层的功能包括：
· 硬件规范的定义，如果电缆、连接器、无线接收器等的工作方式，网卡、集线器等网络设备也工作在物理层
· 编码和信号，物理层把计算机中的二进制0和1转换成可以在物理介质上传输的信号
· 在把数据转换成信号后，物理层负责信号的实际发送和接收
 
 
3TCP/IP模型：TCP/IP分层模型被称作因特网分层模型(Internet Layering Model)、因特网参考模型(Internet Reference Model),一共分为四层。
 
TCP/IP模型分为四层：应用层(Application)、传输层(Host-to-Host Transport)、互联网层(Internet)、网络接口层(Network Interface)
 
(1)第四层——应用层：TCP/IP协议的应用层相当于OSI模型的会话层、表示层和应用层，FTP(文件传输协议)、DNS(域名系统)、HTTP协议、Telnet(网络远程访问协议)。
 
(2)第三层——传输层：提供TCP、UDP两个协议，主要功能是数据格式化、数据确认和丢失重传等。
 
(3)第二层——网络层：该层负责相同或不同网络中计算机之间的通信，主要处理数据包和路由。数据包是网络传输的最小数据单位。通过某条传输路线将数据包传给对方，如IP协议、ICMP协议、IGMP协议。在IP层中，ARP协议用于将IP地址转换为物理地址，ICMP协议用于报告差错和传送控制信息，IP协议在TCP/IP协议组中处于核心地位。
 
(4)第一层——网络接口层：该层对实际的网络媒介的管理，包括操作系统中的设备驱动程序和计算机相对的网络接口卡
 
4OSI模型和TCP/IP模型共同点
· 都是基于独立的协议栈的概念
· 功能大体相似，在两个模型中，传输层及以上的各层都是为了通信的进程提供点到点、与网络无关的传输舒服
· OSI模型与TCP/IP模型传输层以上的层都已应用为主导
 
5OSI模型和TCP/IP模型的差异
· TCP/IP一开始就考虑到多种异构网的互联问题，并将网际协议IP作为TCP/IP的重要组成部分，但ISO最初只考虑到使用一种标准的公用数据网将各种不同的系统互联在一起
· TCP/IP一开始就对面向连接和无连接并重，而OSI在开始时只强调面向连接服务
· TCP/IP有较好的网络管理功能，而OSI到后来才开始这个问题
 
 
2. TCP三次握手，四次挥手，为什么握手及挥手
1TCP三次握手：是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。三次握手的目的是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号并交换TCP窗口大小信息。在socket编程中，客户端执行connect()时，将触发三次握手。
 

 
 
(1)第一次握手：客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X，保存在包头的序列号字段里。然后客户端进入SYN_SEND状态，等待服务器的确认。

 
(2)第二次握手：服务器发回确认包(ACK)应答。SYN标志位和ACK标志位均为1的同时，将确认序号(ACK Number)设置为客户的序列号加1，即X+1。此时服务器进入SYN_RECV状态。

 
(3)第三次握手：客户端再次发送确认包(ACK)，SYN标志位为0，ACK标志位为1。并且把服务器发来ACK的序号字段加1，放在确定字段中发送给对方。客户端和服务器都进入ESTABLISHED状态，完成TCP三次握手/

 
为什么需要三次握手？
“三次握手”的目的是为了防止已失效的连接请求报文段突然又传送到服务端，因而产生错误。例如，已失效的连接请求报文段的这样的情况下：客户端发出的第一个连接请求报文段并没有丢失，而是在某个网络节点长时间的滞留了，以致延误到连接释放以后的某个时间才到达服务器。本来这是一个早已失效的报文段。但服务器收到此失效的连接请求报文段后，就误以为是客户端再次发出的新的连接请求。于是就像客户端发出确认报文段，同意建立连接，假设不采用“三次握手”，那么只要服务器发出确认，新的连接就建立了。由于现在客户端并有没发出建立连接的请求，因此不会理睬服务器的确认，也不会向服务器发送数据。但服务器却以为新的连接已经建立，并一直等待客户端发来数据。这样服务器的很多资源就白白浪费了。采用“三次握手”的办法可以防止上述现象发生。如同刚才那种情况，客户端不会向服务器的确认发出确认。服务器由于收不到确认，就知道客户端并没有要求建立连接。
 
2TCP四次挥手：TCP关闭连接需要发送四个包，因此称为四次挥手。客户端和服务器端均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。

 
(1)第一次挥手：客户端向服务器发送一个FIN标志位为1报文段，将设置序列号(Seq)为X以及确认序号(ACK number)为Z；此时客户端进入FIN_WAIT_1状态，标识客户端没有数据要发送给服务器了，请求关闭连接。
 
(2)第二次挥手：服务器收到了客户端发送的FIN报文段，向客户端返回一个确认标识(ACK)报文段,确认序号(ACK number)设置为客户端的序列号(Seq)加一，即X+1。服务器进入CLOSE_WAIT状态，客户端收到服务器返回的ACK报文后，进入FIN_WAIT_2状态。
 
(3)第三次挥手：服务器会观察自己是否还有数据没有发送给客户端，如果有，先把数据发送给客户端，再发送FIN标识为1的报文，确认序列号(ACK number)为X以及序列号(Seq)设置为Y。如果没有，那么服务器直接发送FIN报文给客户端。请求关闭连接，同时服务器进入LAST_ACK状态。
 
(4)第四次挥手：客户端收到服务器发送的FIN报文段，向服务器发送ACK报文段，将序列号(Seq)设置为服务器端确认序号(ACK)，即X，以及确认序号(ACK number)设置为服务器端序列号(Seq),即Y。然后客户端进入TIME_WAIT状态；服务器收到客户端的ACK报文段以后，就关闭连接；此时，客户端等待2MSL后依然没有回复，则证明服务器端已正常关闭，客户端也可以关闭连接了。
 
为什么是四次握手？
因为当服务器收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文时用来应答的，SYN报文时用来同步的。但是关闭连接时，当服务器收到FIN报文时，很可能并不会立即关闭socket，所以只能先回复一个ACK报文，通知客户端接收到FIN。只有等到服务器所有的报文都发送完了，才能发送FIN报文，因此不能一起发送。故需要四次握手。
 
3. TIME_WAIT和CLOSE_WAIT
1TIME_WAIT为主动关闭时对于复杂的网络状态，TCP的实现提出的其中一种应对措施，为了应对其中一种异常状态。
 
为了理解TIME_WAIT状态的必要性，我们先来假设有这么一种状态导致的问题。以A、B来代指TCP连接的两端，A为主动关闭的一端。
· 四次挥手中，A发FIN，B响应ACK，B在发FIN，A响应ACK实现连接的关闭。而如果A响应的ACK包丢失，B会以为A没有收到自己的关闭请求，然后会重试向A再发FIN包。
 
	如果没有TIME_WAIT状态，A不再保存这个连接的信息，收到一个不存在的连接的包，A会响应RST包，导致B端异常响应。
	 
	此时，TIME_WAIT是为了保证全双工的TCP连接正常终止。
	 
· TCP下的IP层协议时无法保证包传输的先后顺序的。如果双方挥手之后，一个网络四元组(src/dst  ip/port)被回收，而此时网络中还有一个迟到的数据包没有被B接收，A应用程序立刻使用了同样的四元组在创建了一个新的连接后，这个迟到的数据包才到达B，那么这个数据包就会让B以为是A刚发过来的。
	 
	此时，TIME_WAIT的存在是为了保证网络中迷失的数据包正常过期。
 
TIME_WAIT存在的理由：
· 尽可能护送最后的ACK达到对端(使用RRT可能不够，因此用2MSL)
· 新旧四元组互不干扰(关闭连接后，在没有所有网络包都消失时，新旧四元组完全一致可能会导致混乱)
 
4. 浏览器输入URL到响应的过程
总体来说共分成以下几个过程：
· URL输入
· DNS解析
· TCP连接
· 发送HTTP请求
· 服务器处理请求
· 服务器响应请求
· 浏览器解析渲染页面
· 结束连接
 
1输入URL：当我们开始在浏览器中输入网站的时候，浏览器其实已经在智能的匹配可能的URL
 
2DNS解析：DNS解析的过程就是寻找那台机器上有你需要的资源的过程。当在浏览器上输入一个地址是，其实并不是输入的网站真正意义上的地址。互联网上每台计算机的唯一标识是它的IP地址，但IP地址并不方便记忆。用户更喜欢用方便记忆的网站去寻找互联网上的其它计算机，也就是用户输入在浏览器上的网站。一个网站到IP地址的转换，这个过程就是DNS解析。
查找顺序：浏览器缓存à操作系统缓存à本地host文件à路由器缓存àISP DNS缓存à顶级DNS服务器
 
(1)浏览器缓存：首先会向浏览器的缓存中读取上一次访问的记录。
(2)操作系统缓存：查找存储在系统运行内存中的缓存。
(3)host文件：查看本地硬盘的host文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用host文件里面的ip地址。
(4)路由器缓存：有些路由器也有DNS缓存的功能，访问过的域名会存在路由器上。
(5)ISP DNS缓存：互联网服务提供商也会提供DNS服务。在本地查找不到的情况下，就会向ISP进行查询，ISP会在当前服务器的缓存内查找是否有记录，如果有，则返回这个IP，若没有，则会开始向顶级域名服务器请求查询。
(6)顶级DNS服务器：根域名收到请求后，会判别这个域名(.com)是授权给那台服务器管理，并返回这个顶级DNS服务器的IP。请求者收到这台顶级DNS的服务器IP后，会向该服务器发起查询，如果该服务器无法解析，该服务器就会返回下一季的DNS服务器IP，本季继续查找，知道服务器找到主机。

 
（DNS的内容在第25部分）
 
3建立TCP连接
拿到域名对应的IP地址之后，浏览器会以一个随机端口(1024<端口<65535)向服务器WEB程序(常用的有httpd,nginx等)80端口发起TCP的连接请求。这个连接请求达到服务器端后(这中间通过各种路由设备，局域网内除外)，进入到网卡，然后是进入到内核的TCP/IP协议栈(用于识别该链接请求，解封包，一层一层的剥开)，还有可能要进过Netfilter防火墙(属于内核的模块)的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。
发起TCP的连接请求，为三次握手过程。
 
4发送HTTP请求
建立了TCP连接之后，发起一个HTTP请求。一个典型的http request header 一般需要包括请求的方法，例如GET或者POST等，不常用的还有PUT和DELETE、HEAD、OPTION以及TRACE方法，一般的浏览器只能发起GET或者POST请求。
(HTTP请求详细内容在第八部分)
 
5服务器重定向    
 
6服务器处理请求
后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装HTTP Request对象，并上层使用。
 
一些大型的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器以及不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx在请求应用服务器，然后将结果返回客户端，这里Nginx的作用是反向代理服务器。通过也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。
 

 
7服务器返回一个HTTP响应
经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTTP响应。HTTP响应和HTTP请求相似，HTTP响应也由3个部分构成，分别是：
· 状态行
· 响应头（Response Header）
· 空行
· 响应正文
 
(HTTP响应详细内容在第八部分)
 
8浏览器显示HTML
浏览器再收到HTML、CSS、JS文件后，通过WebKit渲染到浏览器上。浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其会知道屏幕上。
 
9连接结束
现在的页面为了优化请求的耗时，默认都会开启持久连接(keep-alive)，那么一个TCP连接确切关闭的时机，是这个tab标签页关闭的时候。这个关闭的过程也就是TCP的四次挥手。关闭是一个全双工的过程，发包的顺序不一定的，一般来说是客户端主动发起的关闭。
(四次握手的详细内容在第二部分)
 
5. TCP与UDP的区别
1TCP的包结构：源端口 16位，目标端口16位，序列号32位，确认号32位，TCP头长度4位，reserved 6位，控制代码6位，窗口大小16位，偏移量16位，校验和16位，选项32位。

 
2UDP的包结构：源端口16位，目的端口16位，长度16位，校验和16位。

 
3UDP
(1)UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它相传宋时就简单地去抓取来自应用程序的数据，并尽可能地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序的生成数据的速度、计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息端放在队列中，应用程序每次从队列中都一个消息段。
 
(2)由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务器可同时向多个客户端传输相同的消息。
 
(3)UDP信息包的标题很短，只有8个字节，相当与TCP的20个字节，信息包的额外开销很小。
 
(4)吞吐量不受拥挤控制算法的调节，只手应用程序生成数据的速率、传输带宽、源端和终端主机性能的限制。
 
(5)UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。
 
(6)UDP是面向报文的。发送方的UDP对应应用程序交下来的报文，在添加首部后就向下交付给IP层。即不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。
 
3TCP和UDP的区别：
· 基于连接与无连接
· 对系统资源的要求（TCP较多，UDP少）
· UDP程序结构简单
· 流模式与数据报模式
· TCP保证数据正确性，UDP可能丢包
· TCP保证数据顺序，UDP不保证
	
	 
 
6. HTTP请求及响应
1HTTP请求所经历的7个步骤：
(1)建立TCP连接：Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，一般TCP连接的端口号是80。
 
(2)Web浏览器向Web服务器发送请求命令：一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令，例如：GET/sample/hello.jsp HTTP/1.1。
 
(3)Web浏览器发送请求头信息：浏览器发送起请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。
 
(4)Web服务器确认：客户端向服务器发出请求后，服务器会给客户端发送应答，例如HTTP/1.1 200 OK,应答的第一部分是协议的版本号和应答状态码。
 
(5)Web服务器发送确认头信息：正如客户端会送同请求发送关于自身的信息一样，服务器页会随同应答向用户发送关于它自己的数据以及请求的文档。
 
(6)Web服务器向浏览器发送数据：Web服务器向浏览器发送头信息后，它会发送一个空包行来表示头信息的发送到此为结束，接着它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。
 
(7)Web服务器关闭TCP关闭：一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在起头信息加入这行代码： Connection:keep-alive
 
2HTTP请求信息有3部分组成：
· 请求方法(GET/POST)、URI、协议/版本
· 请求头(Request Header)
· 请求正文
 
(1)请求方法、URI、协议/版本
POST http://xg.mediportal.com.cn/health/sms/verify/telephone HTTP/1.1
以上代码中“POST”为请求方法、“tp://xg.mediportal.com.cn/health/sms/verify/telephone”表示为URI、“HTTP/1.1”表示协议/版本
 
根据HTTP标准，HTTP请求有多种方法，HTTP1.1目前支持7种请求方法：
GET	请求获取由Request-URI所标识的资源
POST	在Request-URI所标识的资源后附加新的数据
HEAD	请求获取由Request-URI所标识的资源的响应消息报头
OPTIONS	请求查询服务器的性能，或查询与资源相关的选项和需求
PUT	请求服务器存储一个资源，并用Request-URI作为其标识
DELETE	请求服务器删除由Request-URI所标识的资源
TRACE	请求服务器回送收到的请求信息，主要用语测试或诊断
 
(2)请求头(Request Header)
请求头包括许多有关的客户端环境和请求正文的有用信息。
 
User-Agent: DGroupPatient/1.052701.230/Dalvik/2.1.0 (Linux; U; Android 5.1.1; KIW-AL10 Build/HONORKIW-AL10)   //用户发送请求的客户端环境
Content-Type: application/x-www-form-urlencoded; charset=UTF-8   //表单默认的提交数据的格式
Host: xg.mediportal.com.cn   //请求资源的Intenet主机和端口号
Connection: Keep-Alive   //持久连接
Accept-Encoding: gzip   //浏览器能够进行解码的数据编码方式
Content-Length: 33   //请求正文的长度
 
请求头相关信息解释：
Content-Type	是返回消息中非常重要的内容，表示后面的文档属于什么MIME类型。Content-Type: [type]/[subtype]; parameter。例如最常见的就是text/html，它的意思是说返回的内容是文本类型，这个文本又是HTML格式的。原则上浏览器会根据Content-Type来决定如何显示返回的消息体内容
Host	指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回
Accept	浏览器可接受的MIME类型
Accept-Charset	浏览器可接受的字符集
Accept-Encoding	浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间
Accept-Language	浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到
Authorization	授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中
Connection	表示是否需要持久连接。如果Servlet看到这里的值为“Keep- Alive”，或者看到请求使用的是HTTP1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入 ByteArrayOutputStream，然后在正式写出内容之前计算它的大小
Content-Length	表示请求消息正文的长度
Cookie	这是最重要的请求头信息之一
From	请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它
Host	初始URL中的主机和端口
If-Modified-Since	只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答
Pragma	指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝
Referer	包含一个URL，用户从该URL代表的页面出发访问当前请求的页面
User-Agent	浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用
UA-Pixels，UA-Color，UA-OS，UA-CPU	由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型
 
(3)请求正文
请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包括客户提交的查询字符串信息：
telephone=15527177736&userType=1&
 
3HTTP响应由3个部分构成：
· 状态行
· 响应头(Response Header)
· 响应正文
 
以以下内容为列：
HTTP/1.1 200 OK   //状态行
Server: nginx
Date: Tue, 31 May 2016 02:09:24 GMT
Content-Type: application/json;charset=UTF-8
Connection: keep-alive
Vary: Accept-Encoding
Access-Control-Allow-Origin: *
Access-Control-Allow-Headers: X-Requested-With,access_token,access-token,content-type,multipart/form-data,application/x-www-form-urlencoded
Access-Control-Allow-Methods: GET,POST,OPTIONS
Content-Length: 49
 
{"resultCode":1,"resultMsg":"手机号未注册"}   //正文
 
(1)状态行
有协议/版本、数字形式的状态码、及相关描述组成(状态码详细内容在第18部分)
 
(2)响应头(Response Header)
 
(3)响应正文
响应头和响应正文之间同样也是空行，代表响应头的结束，接下来是响应正文中的内容。
 
7. HTTP1.0、HTTP1.1与HTTP2.0的特点与区别
HTTP1.0和HTTP1.1区别：
1长连接：HTTP1.0需要使用keep-alive参数来通知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。
2节约带宽：HTTP1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接收到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。
另外HTTP还支持传送内容的一部分，这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。
 
HTTP1.1和HTTP2.0主要区别：
3多路复用：HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。
4数据压缩：HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这些数据体积小了，在网络上传输就会更快。
5服务器推送：意思是，当我们对支持HTTP2.0的web server请求数据的时候，服务器就顺便把一些客户端需要的资源一起推送到客户端，免得客户端在此创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。
 
8. TCP server最多建立多少个TCP连接
1server最大TCP连接数：server通常固定的在某个本地端口上监听，等待client的连接请求。不考虑地址重用的情况下，即使server端有多个IP，本地监听端口也是独占的，因此server端TCP连接四元组中只有dst ip和dst port是可变的，因此最大TCP连接为客户端IP数x客户端PORT数，对IPV4，不考虑IP地址分类等因素，最大TCP连接数约为2的32次方(IP数)x2的16次方(PORT数)，也就是server端单机最大TCP连接数约为2的48次方。
 
2client最大TCP连接数：client每次发起TCP连接请求时，除非绑定端口，通常会让系统选取一个空闲的本地端口，该端口是独占的，不能和其它TCP连接共享。因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，所以可用端口最多只有65535，因此在client端的情况下，最大的TCP连接数为65535。 
 
9. 滑动窗口
如何保证TCP的可靠传输，这其中有一个关键的部分就是滑动窗口协议。
 
滑动窗口协议：
· TCP协议的使用
· 维持发送方/接收方缓冲区，缓冲区是用来解决网络之间数据不可靠的问题，例如丢包，重复包，出错，乱序
在TCP协议中，发送方和接收方通过各自维护自己的缓冲区。通过商定包的重传机制等一系列操作，来解决不可靠的问题。
 
1如何保证次序

发送方发送一个包1，这时候接收方回复确认包1，接着发送方发送包2，接收方回复确认包2，以此类推下去直到发完所有的包。在这样的情况下吞吐量非常低，发送包1过后必须要等待确认包1的回复，之后才能发送包2.
 
2如何提高吞吐量

如图，发送方将两个发送包同时一起发送，然后一起确认。可以看出改进的方案大大缩短了发送包的时间。接下来，同样有一个问题：如何确认发送包的个数。
 
3如何实现最优解

 
在图中，我们可看出灰色1号2号3号包已经发送完毕，并且已经收到了ACK。而4、5、6、7号包是黄色的，表示已经发送了但未收到接收方的ACK包。8、8、10号包是绿色的，表示还没有发送，但接下来要发送的包。从11到16号包表示还没被读进内存，要等4-10号包有动作才会继续往下发送。
 
正常情况：

从上图可以看出4号对方已经接收并且回复了ACK。“窗口”就往右移了一格，就把11号包读进了我们的缓存，进入了“待发送”的状态。同时8、9号包变成了黄色，表示已经发送出去了。接下来的操作就是一样的，收到ACK后，窗口向右移动读取未发送的包读进缓存，把“待发送”状态的包变为“已发送”。
 
丢包情况：

发生的情况：发送方一直在等待ACK。如果一直等不到的话，发送方也会把读进缓存的包也一起发过去。但是，这时候我们的窗口已经发满了。所以并不能把12号包读进来，而是始终在等待5号包的ACK。
 
超时重传：
如果一直等不到ACK，这时候的解决方法为超时重传机制。
· 回退N帧（Go-Back-N）：如果发送方发送或接收到的包有错误发生，那么从那个错误的包开始到之后所有的包全部重新发送。
	特点： 复杂度低，但不必要的包会再次重发，所以效率不是很高。
	 
· 选择性重传（Selective Repeat）：如果发送发发送或接收到的包有错误发生，那么只重新发送那个错误的包。
	特点：复杂度高，但不需要发送没必要的包，所以效率高。
 
10. TCP流量控制与拥塞控制
1流量控制：
目的：如果发送方发送数据过快，接受方来不及接受，那么就会有分组丢失。为了避免分组丢失，控制发送方的发送速度，使得接收方来得及接受，这就是流量控制。流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。
 
如何实现流量控制：由滑动窗口协议实现(第九部分内容)，滑动窗口协议即保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的ACK中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。

 
流量控制引发的死锁？怎样避免死锁的发生？
当发送方收到了一个窗口为0的应答，发送方便停止发送，等待接收方的下一个应答。但是如果这个窗口不为0的应答在传输过程中丢失，发送方一直等待下去，二接收方以为发送方已经收到该应答，等待接收新的数据，这样双发就相互等待，从而产生死锁。
为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送方收到一个0窗口的应答后就启动该计时器。时间一到遍主动发送报文询问接收方的窗口大小。若接收方仍然返回0窗口，则充值该计时器继续等待；若窗口不为0，则表示应答报文丢失，此时重制发送窗口后开始发送，这样就避免了死锁的产生。
 
2拥塞控制：从丢包情况估计网络的负载情况，调整发送速率，防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制的四种算法，即慢启动（Slow-start）、拥塞避免(Congestion Avoidance)、快重传(Fast Retransmit)、快回复(Fast Recovery)。我们假定：
· 数据是单方向传递，另一个窗口只发送确认
· 接收方的缓存足够大，因此发送方的大小由网络的拥塞程度来决定
 
(1)慢启动：
发送方维持一个叫做拥塞窗口cwnd(congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接收方的接收能力，发送窗口可能小于拥塞窗口。
 
慢启动算法的思路就是，不要一开始就发送大量的数据，现探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。
 
这里用报文段的个数作为拥塞窗口的大小剧烈说明慢启动算法，时机的拥塞窗口大小是以字节为单位的。如下图：

从上图可以看到，一个传输轮次所经历的时间其实就是往返时间RTT，并且每经过一个传输轮次(transmission round)，拥塞窗口cwnd就加倍，呈指数级增长。
 
为了防止cwnd增长过大引起网络拥塞，还需要设置一个慢启动阀值ssthresh状态变量。ssthresh的用法如下：
· 当cwnd<ssthresh时，使用慢启动算法。
· 当cwnd>ssthresh时，该用拥塞避免算法
· 当cwnd=ssthresh时，慢启动与拥塞避免算法任意
 
注意，这里的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，然后逐渐增大。
 
(2)拥塞避免算法：
拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。
无论是在慢启动阶段还是在拥塞避免阶段，只要发送方判断网络出现了拥塞(其根据就是没有按时收到ACK，虽然没有收到Ack可能是其它原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理)，就把慢启动的阀值ssthresh设置为出现拥塞是的发送窗口大小的一半(但不能小于2)。然后把拥塞窗口cwnd重新设置为1，执行慢启动算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。

· 拥塞窗口cwnd初始化为1个报文段，慢启动阀值ssthresh初始值为16
· 执行慢启动算法，指数规律增长到第4轮，即cwnd=16=ssthresh，改为执行拥塞避免算法，拥塞窗口按线性规律增长
· 假定cwnd=24时，网络出现超时(拥塞)，则更新后的ssthresh=12，cwnd重新设置为1，并执行慢启动开始算法，当cwnd=12=ssthresh时，改为执行拥塞避免算法。
 
(3)快重传算法：
快重传要求接收方在收到一个失序的报文段后就立刻发出重复确认(为的是使发送方及早知道有报文段没有到达对方，可提供网络吞吐量约20%)而不要等到自己发送数据时捎带确认。快重传算法规定，发送方之遥一连收到三个重复确认就应当立即重传对方尚未接收到的报文段，而不必继续等待设定的重传计时器时间到期。如下图：

 
(4)快恢复算法：
快重传配合使用的还有快恢复算法，有以下两个要点：
· 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh阀值减半(为了预防网络发生拥塞)。但是接下来并不执行慢启动算法
· 考虑到如果网络出现拥塞的话就不会收到好几个重复的ACK，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢启动算法，而是将cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大。如下图：TCP Reno
	
 
11. TCP序列号的作用
12. socket编程
13. 协议如何封装，报文头部字段
14. HTTP请求方式
HTTP/1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作制定的资源方式。服务器也会根据不同的请求方法做不同的响应。
1GET：GET请求会显示请求指定的资源，一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。
GET方法请求指定的页面信息，并返回响应的主体，GET被认为是不安全的方法，因为GET方法会被网络爬虫等任意的访问。
 
2HEAD：HEAD方法和GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息，HEAD方法常被用于客户端查看服务器的性能。
 
3POST：POST请求会向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法时非幂等的方法，因为这个请求可能会创建新的资源或修改现有的资源。
 
4PUT：PUT请求本身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。
 
5DELETE：DELETE请求用于请求服务器删除所请求的URI(统一资源标识符)所表示的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。
 
6CONNECT：CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的连接与非加密的HTTP代理服务器的通信。
 
7OPTIONS：OPTIONS请求和HEAD类似，一般也是用于客户端查看服务器的性能。这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来替代资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。
 
8TRACE：TRACE请求服务器会显示其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。
 
HTTP1.1后新增的方法：
9PATCH：PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在的资源进行更新。
 
GET与POST的区别：
(1)GET提交：请求的数据会附在URL之后，以?分割URL和传输数据，多个参数用&连接，例如:login.action?name=asdha&password=asdghqwe&verify=%E4%BD%A0。URL的编码格式采用ASCII码，而不是Unicode,这也就是说不能再URL中包含任何非ASCII字符，所有非ASCII字符均需要编码在传输。
 
POST提交：把提交的数据放置时在HTTP包的包体中。
 
(2)传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP现已规范也没有对URL长度进行限制。
而在实际开发中存在的限制主要有：
GET：特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节。对于其它浏览器，理论上没有长度限制，其限制取决于操作系统的支持。
因此对于GET提交时，传输数据会收到URL长度的限制。
 
POST：由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对POST提交数据大小进行限制，Apache、IIS6都有各自的配置。
 
(3)安全性：POST的安全性要比GET的安全性高。注意：这里的所说的安全性和上面GET提到的“安全”不是同一个概念。上面的“安全”的含义仅仅是不做数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登陆页面可能被浏览器缓存，(2)其他人查看浏览器的历史记录，那么别人就可以拿到账号和密码。除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。
 
15. TCP接收窗口、拥塞窗口
（该内容在第九滑动窗口、第十流量控制以及拥塞控制部分）
 
16. 什么时候会对端传窗口的大小
（该内容在第九滑动窗口、第十流量控制以及拥塞控制部分）
	 
17. 连续发送两次http请求，会得到两次结果吗？第二次会比第一次快吗？
18. 状态码，如何排查？及解决
一些常见的状态代码为：
200 – 服务器成功返回网页
404 – 请求的网站不存在
503 – 服务器暂时不可用
 
1xx (临时响应)：用于表示临时响应并需要请求着执行操作才能继续的状态代码。
代码	说明
100（继续）	请求者应继续进行请求。服务器返回此代码以表示，服务器已收到某项请求的第一部分，正等待接收剩余部分。
101（切换协议）	请求者已要求服务器切换协议，服务器已确认并准备进行切换。
 
2xx (成功)：用于表示服务器已成功处理响应请求的状态码。
代码	说明
200（成功）	服务器成功处理了相应请求。通常，这表示服务器已提供了请求的网页。如果您的 robots.txt 文件显示为此状态，则表示 检测工具 已成功检索到该文件。
201（已创建）	请求成功且服务器已创建了新的资源。
202（已接受）	服务器已接受相应请求，但尚未对其进行处理。
203（非授权信息）	服务器已成功处理相应请求，但返回了可能来自另一来源的信息。
204（无内容）	服务器已成功处理相应请求，但未返回任何内容。
205（重置内容）	服务器已成功处理相应请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）。
206（部分内容）	服务器成功处理了部分 GET 请求。
 
3xx (已重定向)：需要进一步操作才能完成请求。此类状态代码通常可用于重定向。建议针对每一请求使用重定向的次数少于五次。可以使用网站站长工具确定 检测工具 是否会抓去重定向网页时遇到问题。抓取下的抓去错误也列出了由于重定向错误而导致 检测工具 无法抓取的网站。
代码	说明
300（多种选择）	服务器可以根据请求来执行多项操作，例如：按照请求者（用户代理）的要求来选择某项操作或者展示列表以便请求者选择其中某项操作。
301（永久移动）	请求的网页已永久移动到新位置。服务器返回此响应（作为对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码通知 检测工具 某个网页或网站已被永久移动到新位置。
302（临时移动）	服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 检测工具 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 检测工具 某个页面或网站已被移动。
303（查看其他位置）	当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。
304（未修改）	请求的网页自上次请求后再也没有修改过。当服务器返回此响应时，不会返回相关网页的内容。
	如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 检测工具 自从上次抓取后网页没有变更，进而节省带宽和开销。
305（使用代理）	请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。
307（临时重定向）	服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 检测工具 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 检测工具 某个页面或网站已被移动。
 
4xx (请求错误)：此类状态代码表示，响应请求可能出错，已阻止了服务器对请求的处理。
代码	说明
400（错误请求）	服务器不理解相应请求的语法。
401（未授权）	请求要求进行身份验证。登录后，服务器可能会返回对页面的此响应。
403（已禁止）	服务器正在拒绝相应请求。如果 检测工具 在尝试抓取网站的有效网页时收到此状态代码（您可在  网站站长工具中运行工具下的抓取错误页上进行查看），则可能是因为您的服务器或主机正在阻止 检测工具 进行访问。
404（未找到）	服务器找不到请求的网页。例如，如果相应请求是针对服务器上不存在的网页进行的，那么服务器通常会返回此代码。
	如果您的网站上没有 robots.txt 文件，而您在  网站站长工具中的已拦截的网址页上看到此状态，那么这就是正确的状态。然而，如果您有 robots.txt 文件而又发现了此状态，那么，这说明您的 robots.txt 文件可能是命名错误或位于错误的位置。（该文件应当位于顶级域名上，且应当名为 robots.txt）。
	如果您在 检测工具 尝试抓取的网址上看到此状态，那么这表示 检测工具 追踪的可能是另一网页中的无效链接（旧链接或输入有误的链接）。
405（方法禁用）	禁用相应请求中所指定的方法。
406（不接受）	无法使用相应请求的内容特性来响应请求的网页。
407（需要代理授权）	此状态代码与 401（未授权）类似，但却指定了请求者应当使用代理进行授权。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。
408（请求超时）	服务器在等待请求时超时。
409（冲突）	服务器在完成请求时遇到冲突。服务器必须在响应中包含该冲突的相关信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会提供两个请求的差异列表。
410（已删除）	如果请求的资源已被永久删除，那么服务器会返回此响应。该代码与 404（未找到）代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 404 代码出现。如果资源已永久删除，您应使用 301 指定资源的新位置。
411（需要有效长度）	服务器不会接受包含无效内容长度标头字段的请求。
412（未满足前提条件）	服务器未满足请求者在请求中设置的其中一个前提条件。
413（请求实体过大）	服务器无法处理相应请求，因为请求实体过大，已超出服务器的处理能力。
414（请求的 URI 过长）	请求的 URI（通常为网址）过长，服务器无法进行处理。
415（不支持的媒体类型）	相应请求的格式不受请求页面的支持。
416（请求范围不符合要求）	如果相应请求是针对网页的无效范围进行的，那么服务器会返回此状态代码。
417（未满足期望值）	服务器未满足“期望”请求标头字段的要求。
 
5xx (服务器错误)：此类状态码表示，服务器在尝试处理响应请求时发生内部错误，此类错误往往与服务器本身有关。
代码	说明
500（服务器内部错误）	服务器遇到错误，无法完成相应请求。
501（尚未实施）	服务器不具备完成相应请求的功能。例如，当服务器无法识别请求方法时，可能便会返回此代码。
502（错误网关）	服务器作为网关或代理，从上游服务器收到了无效的响应。
503（服务不可用）	目前无法使用服务器（由于超载或进行停机维护）。通常，这只是暂时状态。
504（网关超时）	服务器作为网关或代理，未及时从上游服务器接收请求。
505（HTTP 版本不受支持）	服务器不支持相应请求中所用的 HTTP 协议版本。
 
排查502、503、504:
502: 出现502错误，通常意味着一两个机器以及不正确，简单来说就是机器挂掉了。理论来说，nginx执行请求的时候，却收到了上游服务器的无效响应。
 
503:请求用户量太多，服务器为了保护自己不挂掉，拒绝某些用户的访问，这些用户就会收到503错误。通常过一会儿在访问该网站或尝试强刷新页面，问题一般就能解决。
 
504:通常这个错误是由于nginx配置不当引起的，比如将nginx的超时时间设置为300，那么如果此次请求的响应时间超过了300，就会看到504这个报错，请求超时。
 
 
19. HTTP缓存机制
20. HTTP长连接、短链接
21. 重传ack的时机
22. 拥塞窗口要不要把自己的大小发给接收方
（该内容在第九滑动窗口、第十流量控制以及拥塞控制部分）
	 
23. 路由器是哪一层？有什么功能？路由寻址，路由表
24. DNS
25. cookie和session的区别
1由于HTTP协议是无状态的协议，所以服务器需要记录用户的状态时，就需要用session来识别具体的用户。典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务器要为特定的用户创建了特定的session，用于标识这个用户，并且跟踪用户，这样才知道购物车里面有什么。这个session是保存在服务器端的，有一个唯一标志。在服务端保存session的方法很多，内存、数据库、文件都有。集群的时候也要考虑session的转移，在大型网站中，一半会有专门的session服务器集群，用来保存用户会话，这个时候session信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放session。
 
2思考一下服务端如何识别特定的用户？这个时候需要cookie了，每次HTTP请求的时候，客户端都会发送响应的cookie信息到服务器。实际上大多数的应用都是cookie来实现session跟踪的，第一次创建session的时候，服务器会在HTTP协议中告诉客户端，需要在cookie里面记录一个session ID，以后每次请求把这个会话ID发送到服务器，就可以知道是哪一个用户了。如果客户端的浏览器禁用了cookie的话，在这样情况下，会使用一种叫URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被加上如sid=xxxxx这样的参数，服务器据此来识别用户。
 
3cookie其实还可以用在一些方便用户的场景下，假设用户某次登陆过一个网站，下次登录的时候不想再输入账号了。这个信息可以写在cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮用户填上了。
 
Session是在服务器端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。
Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。
 
26. 网关
27. 查看占用了80端口的进程
netstat -an | grep :80
 
28. 进度条如何实现
29. 断点上传如何实现
30. TCP粘包
(详细部分：https://juejin.im/post/5b67902f6fb9a04fc67c1a24)
