---
layout: article
title: 网络相关知识点总结
aside:
  toc: true
key: 
---

# 网络协议
## 网络分层的意义
- 各层之间相互独立，高层是不需要知道底层的功能如何实现的，只需要知道通过与底层的接口就可以获得所需要的服务；
- 灵活性好，各层都可以采用最恰当的技术实现；
- 易于实现和标准化，由于采用了规范的层次结构去组织网络功能与协议，因为可以将计算机网络复杂的通信过程，划分为有序的连续动作与有序的交互过程，有利于将网络复杂的通信工作过程简化为一系列可以控制和实现的功能模块。
 

## 两种网络分层模型
### OSI 模型
即开放系统互连（Open System Interconnection），是网络通信的一种通用框架，分为七层，并且定义了在每一层上数据的处理方式。

![OSI模型七层]({{site.url}}/assets/images/network/image001.gif "OSI模型七层")

- **第七层 -- 应用层（Application）**：针对特定应用的协议
它的作用是为**应用程序提供服务**并规定应用程序中通讯相关的细节，也就是为应用提供服务。常见的协议有HTTP、FTP、TELNET、SMTP等。
  - HTTP：超文本传输协议，提供数据供浏览器使用；
  - FTP：文件传输协议，用来在客户机和FTP服务器之间传输文件；
  - DHCP：动态主机配置协议，DHCP服务器为客户机动态分配IP地址；
  - POP3:邮件接收协议，用于从POP3服务器接收邮件；
  - SMTP：邮件发送协议，用于通过SMTP服务器发送邮件。

- **第六层 -- 表示层（Presentation）**：设备固有数据格式和网络标准数据格式的转换
这层的主要功能是：**转换**、**压缩**和**加密**。它的作用是将应用处理的信息转化为适合网络输出的格式，或者将来自下一层的数据转换为上一层能处理的格式。它主要负责数据格式的转换。具体来说，就是将设备固有的数据格式转换为网络标准格式。常见的协议有ASCII、SSL/TLS等。

- **第五层 -- 会话层（Session）**：建立、管理和维护通信，管理传输层以下的分层
这层的作用就是为**创建**、**管理**和**终止会话**提供必要的方法。这些方法一般以API的形式出现，常用的API有NetBIOS（Network Basic Input/Output Interface，网络基本输入/输出系统）、RPC（Remote Procedure Cell，远程过程调用）和Socket API。可以理解为两个应用程序进程之间的逻辑连接，两个应用程序通过这个逻辑连接在一段时间内交换数据。

- **第四层 -- 传输层（Transprt）**：管理两个节点之间的数据传输（确保数据被可靠地传送给目标地址）
传输层起着**可靠传输**的作用。这里的“传输”指的是**端对端**或者**主机对主机**的传输。只在通信双发节点进行处理，而不需要在路由器上处理。
传输层上最重要的两个协议是**TCP（面向连接的协议，Connection-Oriented）**和**UDP（无连接的协议，Connection-Less）**。

- **第三层 -- 网络层（Network）**：地址管理和路由选择
网络层负责将**数据传输到目标地址**，目标地址可以使用多个网络通过路由器连接而成的某一个地址。因此这一层主要负责寻址和路由选择。主要由IP、ICMP两个协议组成。
网络层将数据从发送端的主机发送到接收端的主机，两台主机可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址用的是IP地址，IP地址通过不断转发到更近的IP地址，最终可以到达目标地址。

- **第二层 -- 数据链路层（Data Link）**：互连设备之间传送和识别数据帧
数据链路层负责**物理层面上互连的节点之间的通信传输**。它关心的是如何把**数据发送到本地网络中去**，平时常说的**LAN**技术，如以太网(Ethernet)、令牌环网(Token Ring)、光纤分布数据接口(FDDI)和802.11(WIFI)都定义在这一层。
数据链路层又分为两个子层：**逻辑链路控制层（Logical Link Control）**和**介质访问控制层（Media Access Control）**。
数据链路层有一个重要的概念，即**MAC地址**，可以称为物理地址、硬件地址、以太网地址等。每个网卡（Network Interface Card）都有一个**唯一的MAC地址**，数据链路层通过MAC地址来确保数据能够正确被发送到目标设备。MAC地址有一个**48位二进制整数**，通常的表示方法是用-隔开的6个十六进制整数，如14-FE-B5-B0-2B-96。

- **第一层 -- 物理层（Physical）**：将数据0、1转换为电压和脉冲光传输给屋里的传输介质
物理层位于OSI的底层，所有其他层的数据最终都必须经由物理层才能发送出去。物理层的功能包括：
  - **硬件规范的定义**，如电缆、连接器、无线接收器等的工作方式，网卡、集线器等网络设备也工作在物理层；
  - **编码和信号**，物理层把计算机中的二进制0和1转换成可以在物理介质上传输的信号；
  - 再把数据转换成信号后，物理层负责**信号的实际发送和接收**。
 

### TCP/IP 模型
TCP/IP分层模型被称作因特网分层模型（Internet Layering Model）、因特网参考模型（Internet Reference Model），一共分为四层：

- **第四层 -- 应用层（Application）**：TCP/IP模型的**应用层**相当于OSI模型的**会话层**、**表示层**和**应用层**，常用协议FTP(文件传输协议)、DNS(域名系统)、HTTP协议、Telnet(网络远程访问协议)。

- **第三层 -- 传输层（Transport）**：提供**TCP**和**UDP**两个协议，主要功能是**数据格式化**、**数据确认**和**丢失重传**等。

- **第二层 -- 网络层（Network）**：该层负责**相同和不同网络中计算机之间的通信**，主要处理**数据包**和**路由**。数据包是网络传输的最小数据单位，通过某条传输路线将数据包传给对方，如IP协议、ICMP协议、IGMP协议。在IP层中，**ARP协议**用于将**IP地址转换为物理地址**，**ICMP协议**用于**报告差错**和**传送控制信息**，**IP协议**在TCP/IP协议组中处于核心地位。

- **第一层 -- 网络接口层（Network Interface）**：该层对实际的**网络媒介的管理**，包括操作系统中的设备驱动程序和计算机相对的网络接口卡。
 

### OSI模型和TCP/IP模型的相同点
- 都是采用协议分层的方法；
- 层次协议的功能大体相同；
- 两种模型都可以解决异构网的互连；
- 都是计算机通信的国际标准，OSI原则上是国际通用，TCP/IP工业上使用较多；
- 都提供TCP和UDP；
- 都是基于一种协议集的概念，协议集是一组完成特定功能的相互独立的协议。
 

### OSI模型和TCP/IP模型的差异
- TCP/IP一开始就考虑到多种异构网的互连问题，并将网际协议IP作为TCP/IP的重要组成部分。ISO和CCITT最初只考虑到全世界都使用一种统一的标准公用数据网将各种不同的系统互连在一起，后来，ISO意识到网际协议IP的重要性，然而已经来不及了，只好在网络层划分一个子层来完成类似TCP/IP中的IP的作用。

- TCP/IP一开始就对面对连接服务和无连接服务并重，而OSI在开始的时只强调面向连接这一种服务。OSI之后才开始制定另一种无连接服务的有关标准。

- TCP/IP较早就有很好的网络管理功能，而OSI到后来才考虑这个问题。

- TCP/IP的不足：TCP/IP模型对“服务”，“协议”和“接口”等概念没有很清楚的区分开，TCP/IP模型的通用性比较差。很难用来描述其他种类的协议栈，TCP/IP的网络接口严格来说并不是一个层次而仅仅是一个接口。

# TCP/IP 协议
在`TCP/IP`协议中，不同协议层对包都进行了封装：
- 从用户的数据报文进过封装传递给传输层；
- 传输层封装TCP首部，上一层传递过来的数据为TCP数据，传递给网络层；
- 网络层封装IP首部，上一层传递过来的数据为IP数据，传递给数据链路层；数据链路层封装帧首部；
- 帧数据是最终在物理网络上传输字节序列。

过长的IP报文段可能会被分包传输。拆包的过程则是当帧数据到达时，沿着协议栈从底自上的进行拆解。

数据从上到下封装的格式为：`比特（bit） -> 帧（frame） -> 包（packet） -> 段（segment） -> 数据（data）`。

!["tcp/ip的数据封包与拆解"]({{site.url}}/assets/images/network/image002.png "tcp/ip的数据封包与拆解")

下面的内容将从TCP/IP模型的应用层到网络接口层，进行详解。

# 应用层
应用层为`tcp/ip协议`的最上层，也就是我们开发的应用程序，位于这一层。在这一层包含一些协议，比如：`DNS(域名解析协议)`、`SMTP(简单邮件传输协议)`、`FTP(文件传输协议)`、`HTTP(超文本传输协议)`、`Telnet(网络远程协议)`等。

## DNS 域名解析协议
### 域名注册
- **domain name 域名**
域名是一个访问网站或者是应用程序的名字，例如，当用户在浏览器上输入的`www.example.com`。为了是你的网站或者是应用程序在互联网上可用，就必须注册一个域名。
 

- **domain registrar 域注册商**
域注册商是一个公司经ICANN（互联网名称和数字地址分配机构）认可的公司，可以处理特定顶级域名（TLD）的域名注册。例如，Amazon Registrar, Inc. 是一个域名注册商对于`.com`、`.net`、`.org`。
 

- **domain registry 域注册局**
域注册局是一个公司有权利去销售一些特定的顶级域名（TLD）。域注册表定义了用于注册域的规则，例如地理TLD的居住要求。 域注册中心还维护具有相同TLD的所有域名的权威数据库。 注册表的数据库包含每个域的信息，例如联系信息和名称服务器。
 

- **domain reseller 域代理商**
域代理商是一个公司为注册服务商出售域名。
 

- **top-level domain (TLD) 顶级域名**
顶级域名是域名的最后一部分，例如`.com`、`.net`、`.org`。
 

### DNS 域名解析协议概念
- **A 记录**
A记录，又称主机记录，是将一个域名解析成一个IP地址。当访问一个域名时DNS会通过A记录解析出相对应的IP地址，以达到后续访问的目的。


- **CNAME 记录**
CNAME记录，又称别名记录，是将一个域名，映射到另外一个域名。这两个别名的全称就`http://www.mydomain.com/`和`mail.mydomain.com`。实际上他们都指向 `host.mydomain.com`。


- **DNS 解析**
DNS解析的过程就是寻找那台机器上有你需要的资源的过程。当在浏览器上输入一个地址时，其实并不是输入的网站真正意义上的地址。互联网上每台计算机的唯一标识是它的IP地址，但IP地址并不方便记忆。用户更喜欢用方便记忆的网站去寻找互联网上的其它计算机，也就是用户输入在浏览器上的网站。一个网站到IP地址的转换，这个过程就是DNS解析。查找顺序：`浏览器缓存 -> 操作系统缓存 -> 本地host文件 -> 路由器缓存 -> ISP DNS缓存 -> 顶级DNS服务器`。
  - **浏览器缓存**：首先会向浏览器的缓存中读取上一次访问的记录；
  - **操作系统缓存**：查找存储在系统运行内存中的缓存；
  - **host文件**：查看本地硬盘的host文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用host文件里面的ip地址；
  - **路由器缓存**：有些路由器也有DNS缓存的功能，访问过的域名会存在路由器上；
  - **ISP DNS缓存**：互联网服务提供商也会提供DNS服务。在本地查找不到的情况下，就会向ISP进行查询，ISP会在当前服务器的缓存内查找是否有记录，如果有，则返回这个IP，若没有，则会开始向顶级域名服务器请求查询。
  - **顶级DNS服务器**：根域名收到请求后，会判别这个域名(.com)是授权给那台服务器管理，并返回这个顶级DNS服务器的IP。请求者收到这台顶级DNS的服务器IP后，会向该服务器发起查询，如果该服务器无法解析，该服务器就会返回下一季的DNS服务器IP，本机继续查找，直到服务器找到主机。


### dig 命令
通过`dig`命令查询主机地址的信息：
!["dig www.baidu.com"]({{site.url}}/assets/images/network/image003.png "dig www.baidu.com信息")
- `dig`命令的版本以及输入参数的信息
```
; <<>> DiG 9.10.6 <<>> www.baidu.com
;; global options: +cmd
```
- `dig`命令返回的DNS解析的技术信息
```
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 13539
;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1
```
- 查询的域名信息
```
;; QUESTION SECTION:
;www.baidu.com.			IN	A
```
- `dig`查询到的结果，其中A为A记录，CNAME为CNAME记录
```
;; ANSWER SECTION:
www.baidu.com.		182	IN	CNAME	www.a.shifen.com.
www.a.shifen.com.	151	IN	A	163.177.151.110
www.a.shifen.com.	151	IN	A	163.177.151.109
```
- 剩余数据记录
```
;; Query time: 12 msec
;; SERVER: 120.80.88.88#53(120.80.88.88)
;; WHEN: Mon Jan 13 18:15:10 CST 2020
;; MSG SIZE  rcvd: 101
```


## HTTP 协议
**HTTP（超文本传输协议）** 是一个用于传输超媒体文档（例如HTML）的应用层协议。它是为Web浏览器与Web服务器之间的通信而设计的，但也可以用于其他目的。HTTP 遵循经典的**CS（客户端-服务器端）模型**，客户端打开一个连接以发送请求，然后等待它收到服务器端响应。HTTP 是**无状态协议**，这意味着服务器不会再两个请求之间保留任何数据（状态）。该协议虽然通常基于**TCP/IP层**，但可以在任何可靠的传输层上使用；也就是说，不像UDP，它是一个不会静默丢失消息的协议。RUDP-作为UDP的可靠化升级版本-是一个合适的替代选择。


### HTTP 的基本性质
- **HTTP 是简单的**：虽然下一代`HTTP/2`协议将HTTP消息封装到了帧（frames）中，HTTP大体上还是被设计得简单易读；


- **HTTP 是可拓展的**：在`HTTP/1.0`中出现的`HTTP headers`让协议扩展变得非常容易。只要服务端和客户端就新`headers`达成语义一致，新功能就可以被轻松加入进来。


- **HTTP是无状态，有会话的**：无状态表示在同一个连接中，两个执行成功的请求之间是没关系的。这就会出现一个问题，用户没有办法在同一个网站进行连续交互，比如在一个电商网站里，用户把商品添加入购物车，当切换页面再次添加商品，这两次添加商品之间没有关系，浏览器无法知道用户最终选择了哪些商品。而可以使用`HTTP Cookies`，使得每次请求都能共享相同的上下文信息，达成相同的状态。


- **HTTP 和连接**：一个连接是由**传输层**来控制的，这从根本上不属于HTTP的范围。HTTP并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。在互联网中，有两个最常用的传输层协议：TCP是可靠的，而UDP不是。因此，HTTP依赖于面向连接的TCP进行消息传递，但连接并不是必须的。


### HTTP 消息
HTTP消息是服务器和客户端之间交换数据的方式。有两种类型的消息：请求（request）—— 客户端发送消息给服务器；响应（response）—— 来自服务器的应答。

HTTP 请求和响应具有相似的结构，由以下部分组成：
- 一行起始行用于描述要执行的请求，或者是对应的状态，成功或失败。这个起始行总是单行的。
- 一个可选的 HTTP 头集合指明请求或描述消息征文。
- 一个空行指示所有关于请求的元数据已经发送完毕。
- 一个可选的包含请求相关数据的正文（比如HTML表单），或者响应相关的文档。正文的大小有起始行的HTTP头来指定。

### HTTP 请求结构
1. **起始行**：HTTP请求是由客户端发出的消息，用来使服务器执行动作。*起始行（start-line）*包含三个元素：
`POST / HTTP 1.1`

`GET /background.png HTTP/1.0`

`HEAD /test.html?query=alibaba HTTP/1.1`

`OPTIONS /anypage.html HTTP/1.0`

`GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1`

- 一个 *HTTP方法（HTTP method）*，例如`GET`、`PUT`和`HEAD`，描述要执行的动作。
- *请求目标（request target）*，通常是一个`URL`，或者是协议、端口和域名的绝对路径，通常以请求的环境为特征。请求的格式因不同的HTTP 方法而异。可以是：
  - 一个绝对路径，末尾跟上'?'和查询字符串；
  - 一个完整的URL，被称为*绝对形式（absolute form）*；
  - 由域名和可选端口（以`:`为前缀）组成的 URL 的authority component。仅在使用`CONNECT`建立HTTP隧道时才使用。
  `CONNECT developer.mozilla.org:80 HTTP/1.1`
  - *星号形式（asterisk form）*，一个简单的的星号(`*`)，配合`OPTIONS`方法使用，代表整个服务器。
  `OPTION * HTTP/1.1`
- *HTTP 版本（HTTP version）*，定义了剩余报文的结构，作为对期望的响应版本的指示符。


2. **Headers**：来自请求的 HTTP headers 遵循和 HTTP header 相同的基本结构：不区分大小写的字符串，紧跟着的冒号(`:`)和一个结构取决于 header 的值。整个 header（包括值）由一行组成，这一行可以相当长。
   - *General headers*，例如`Via`，适用于整个报文；
   - *Request headers*，例如`User-Agent`、`Accept-Type`，通过进一步的定义，或者给定上下文(例如`Referer`)，或者进行有条件的限制 (例如`If-None`) 来修改请求。
   - *Entity headers*，例如`Content-Length`，适用于请求的 body。显然，如果请求中没有任何 body，则不会发送这样的头文件。
!["http request headers"]({{site.url}}/assets/images/network/HTTP_Request_Headers2.png "http request headers")


3. **Body**：请求的最后一部分是它的body。不是所有的请求都有一个 body：例如获取资源的请求，`GET`，`HEAD`，`DELETE` 和 `OPTIONS`，通常它们不需要 body。 有些请求将数据发送到服务器以便更新数据：常见的的情况是 `POST` 请求（包含 HTML 表单数据）。Body 大致分为两类：
- *Single-resource bodies*，由一个单文件组成。该类型 body 由两个 header 定义： `Content-Type` 和 `Content-Length`.
- *Multiple-resource bodies*，由多部分 body 组成，每一部分包含不同的信息位。通常是和 `HTML Forms` 连系在一起。


### HTTP 响应结构
1. **状态行**：HTTP 响应的起始行被称作 *状态行（status line）*，包含以下信息：
`HTTP/1.1 404 Not Found`
- *协议版本*，通常为 `HTTP/1.1`。
- *状态码（status code）*，表明请求是成功或失败。常见的状态码是 `200`，`404`。
- *状态文本（status text）*。一个简短的，纯粹的信息，通过状态码的文本描述，帮助人们理解该 HTTP 消息。


2. **Headers**：响应的 HTTP headers 遵循和任何其它 header 相同的结构：不区分大小写的字符串，紧跟着的冒号 (`:`) 和一个结构取决于 header 类型的值。 整个 header（包括其值）表现为单行形式。响应头可分为：
- *General headers*，例如`Via`，适用于整个报文。
- *Response headers*，例如`Vary`和`Accept-Ranges`，提供其它不符合状态行的关于服务器的信息。
- *Entity headers*，例如`Content-Length`，适用于请求的 body。显然，如果请求中没有任何 body，则不会发送这样的头文件。
!["http response headers"]({{site.url}}/assets/images/network/HTTP_Response_Headers2.png "http response headers")


3. **Body**：响应的最后一部分是 body。不是所有的响应都有 body：具有状态码 (如`201`或`204`) 的响应，通常不会有 body。
Body 大致可分为：
- *Single-resource bodies*，由已知长度的单个文件组成。该类型 body 由两个 header 定义`Content-Type`和`Content-Length`。
- *Single-resource bodies*，由**未知**长度的单个文件组成，通过将`Transfer-Encoding`设置为 chunked 来使用 chunks 编码。
- *Multiple-resource bodies*，由多部分 body 组成，每部分包含不同的信息段。但这是比较少见的。


### HTTP/2 帧
在 HTTP/1.x 报文有一些性能上的缺点：
- Header不会被压缩。
- 两个报文之间的header通常相似，但仍然需要重复传输。
- 无法复用。

HTTP/2 添加了一个步骤，将HTTP/1.x消息分为帧并嵌入到流（stream）中。数据帧和报头帧分离，这将允许报头压缩。将多个流组合，该过程称为 *多路复用（multiplexing）*。 

!["HTTP/2 帧"]({{site.url}}/assets/images/network/Binary_framing.png "HTTP/2 帧")


### HTTP 请求方法
HTTP 定义了一组请求方法，以表明要对给定资源执行的操作。指示针对给资源要执行的期望动作。每个请求方法都实现了不同的语义，但一些共同的特征由一组恭喜那个：例如一个请求方法可以是 *safe*，*idempotent*，*cacheable*。


> *safe 安全*：一个 HTTP方法是安全的，就意味着不会它不会修改服务器的状态。换句话说，一个安全的方法，它是 read-only只读 操作。 `GET` 、 `HEAD` 、 `OPTIONS` 是安全的。所有安全的方法，同样是幂等的。但幂等的方法不一定是安全的，例如 `PUT` 和 `DELETE`。
*idempotent 幂等*：一个 HTTP方法 是幂等的，就意味着客户端发送一个特定的请求，无论一次或者是多次，造成的影响都是一样的，同时保持服务器是相同的状态。换句话说，一个幂等的方法不应该有任何副作用。`GET`、 `HEAD`、 `PUT` 和 `DELETE` 方法都是幂等的，但 `POST` 不是。 所有的安全的方法同样是幂等的。


`GET`

GET 方法请求一个指定资源的表示形式。使用GET的请求应该只被用于获取数据。


`HEAD`

HEAD 方法请求一个与GET请求 的响应相同的响应，但没有body。


`POST`

POST 方法用于将body提交到指定的资源，通常导致在服务器上的状态变化或者副作用。


`PUT`

PUT方法用请求有效载荷替换目标资源的所有当前表示。
PUT 与 POST 方法的区别在于，PUT方法是幂等的：调用一次与连续调用多次是等价的（即没有副作用），而连续调用多次POST方法可能会有副作用，比如将一个订单重复提交多次。

`DELETE`

DELETE方法删除指定的资源。


`CONNECT`
CONNECT方法建立一个到由目标资源标识的服务器的隧道。


`OPTIONS`

OPTIONS方法用于描述目标资源的通信选项。


`TRACE`

TRACE方法沿着到目标资源的路径执行一个消息环回测试。


`PATCH`

PATCH方法用于对资源应用部分修改。


### HTTP 响应代码
HTTP 响应状态代码指定特定 HTTP请求 是否已经成功完成。响应分为五类：信息响应（100-199），成功响应（200-299），重定向（300-399），客户端错误（400-499）和服务器错误（500-599）。


**消息响应**

`100 Continue`

这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。
为了让服务器检查请求的首部，客户端必须在发送请求实体前，在初始化请求中发送 `Expect: 100-continue` 首部并接收 `100 Continue` 响应状态码。

`101 Switching Protocol`

该代码是响应客户端 `Upgrade` 标头发送的，并且指示服务器也正在切换的协议。



**成功响应**

`200 OK`

请求成功。成功的含义取决于HTTP方法：
- GET：资源已被提取并在消息正文中传输。
- HEAD：实体标头位于消息正文中。
- POST：描述动作结果的资源在消息体中传输。
- TRACE：消息正文包含服务器收到的请求消息。


`201 Created`

该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应。


`202 Accepted`

请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。
服务器已接受到请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会，也可能不会被执行。在异步操作的场合下，发送这种状态码更加方便。


`203 Non-Authoritative Information`

服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。

`204 No Content`

HTTP `204 No Content` 成功状态响应码，表示该请求已经成功了，但是客户端客户不需要离开当前页面。默认情况下 204 响应是可缓存的。一个 `ETag` 标头包含在此类响应中。 
使用惯例是，在 `PUT` 请求中进行资源更新，但是不需要改变当前展示给用户的页面，那么返回 204 No Content。如果创建了资源，则返回 `201 Created` 。如果应将页面更改为新更新的页面，则应改用 `200 OK` 。

`205 Reset Content`

服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，**立即重置表单**，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。

`206 Partial Content`

服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现**断点续传**或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。


**重定向**

`300 Multiple Choice`

表示该请求拥有多种可能的响应。用户代理或者用户自身应该从中选择一个。由于没有如何进行选择的标准方法，这个状态码极少使用。
假如服务器可以提供一个优先选择，那么它应该生成一个 `Location` 首部。

`301 Moved Permanently`

说明请求的资源已经被移动到了由`Location`头部指定的url上，是固定的不会再改变。搜索引擎会根据该响应修正。
尽管标准要求浏览器在收到该响应并进行重定向时不应该修改http method和body，但是有一些浏览器可能会有问题。所以最好是在应对 `GET` 或 `HEAD` 方法时使用 `301` ，其他情况使用 `308` 来替代 `301`。

`302 Found`

说明请求的资源被暂时的移动到了由 `Location` 头部指定的 `URL` 上。浏览器会重定向到这个 `URL`但是搜索引擎不会对该资源的链接进行更新。
即使规范要求浏览器在重定向时保证请求方法和请求主体不变，但并不是所有的用户代理都会遵循这一点，你依然可以看到有缺陷的软件的存在。所以推荐仅在响应 `GET` 或 `HEAD` 方法时采用 `302` 状态码，而在其他时候使用 `307 Temporary Redirect` 来替代，因为在这些场景下方法变换是明确禁止的。
在确实需要将重定向请求的方法转换为 `GET` 的场景下，可以使用 `303 See Other`。例如在使用 `PUT` 方法进行文件上传操作时，需要返回确认信息（例如“你已经成功上传了xyz”）而不是上传的资源本身，就可以使用这个状态码。

`303 See Other`

通常作为 `PUT` 或 `POST` 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 `GET`。

`304 Not Modified`

说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在一些**安全的方法（safe）**，例如 `GET` 或 `HEAD` 或在请求中附带了头部信息： `If-None-Match` 或`If-Modified-Since`。
如果是 `200 OK` ，响应会带有头部 `Cache-Control`, `Content-Location`, `Date`, `ETag`, `Expires`，和 `Vary`。

`307 Temporary Redirect`

请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。

`308 Permanent Redirect`

这意味着资源现在永久位于由 `Location:` HTTP Response 标头指定的另一个 `URI`。 这与 `301 Moved Permanently` HTTP 响应代码具有相同的语义，但用户代理不能更改所使用的 `HTTP` 方法：如果在第一个请求中使用 `POST`，则必须在第二个请求中使用 `POST`。

> 注：`303`、`307` 和 `308` 是 `HTTP/1.1` 对 `302` 和 `301` 的规范。但工业上大多数情况还是使用 `302` 和 `301` 状态码。



**客户端响应**

`400 Bad Request`

1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。
2、请求参数有误。

`401 Unauthorized`

指的是由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。
这个状态码会与 `WWW-Authenticate` 首部一起发送，其中包含有如何进行验证的信息。
这个状态类似于 `403`， 但是在该情况下，依然可以进行身份验证。

`403 Forbidden`

指的是服务器端有能力处理该请求，但是拒绝授权访问。
这个状态类似于 `401`，但进入该状态后不能再继续进行验证。该访问是长期禁止的，并且与应用逻辑密切相关（例如不正确的密码）。

`404 Not Found`

指的是服务器端无法找到所请求的资源。

`405 Method Not Allowed`

表明服务器禁止了使用当前 `HTTP` 方法的请求。需要注意的是，`GET` 与 `HEAD` 两个方法不得被禁止，当然也不得返回状态码 `405`。

`406 Not Acceptable`

请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。
但实际情况下，这个状态码很少使用，因为为保证用户网站的体验度，一般会将相关的消息头忽略，同时给用户提供一个看得见摸得着的页面。

`407 Proxy Authentication Required`

指的是由于缺乏位于浏览器与可以访问所请求资源的服务器之间的代理服务器（proxy server）要求的身份验证凭证，发送的请求尚未得到满足。

`408 Request Timeout`

请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。

`409 Conflict`

表示请求与服务器端目标资源的当前状态相冲突。
冲突最有可能发生在对 `PUT` 请求的响应中。例如，当上传文件的版本比服务器上已存在的要旧，从而导致版本冲突的时候，那么就有可能收到状态码为 409 的响应。



**服务器响应**

`500 Internal Server Error`

服务器遇到了不知道如何处理的情况。
这个错误代码是一个通用的“万能”响应代码。有时候，对于类似于 500 这样的错误，服务器管理员会更加详细地记录相关的请求信息来防止以后同样错误的出现。

`501 Not Implemented`

此请求方法不被服务器支持且无法被处理。只有 `GET` 和 `HEAD` 是要求服务器支持的，它们必定不会返回此错误代码。
`501` 可以被缓存。

`502 Bad Gateway`

表示作为网关或代理角色的服务器，从上游服务器（如tomcat、php-fpm）中接收到的响应是无效的。

`503 Service Unavailable`

服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。

`504 Gateway Timeout`

表示扮演网关或者代理的服务器无法在规定的时间内获得想要的响应。

`505 HTTP Version Not Supported`

服务器不支持请求中所使用的HTTP协议版本。

********

# Wireshark 抓包


