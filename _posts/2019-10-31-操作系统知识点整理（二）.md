---
layout: article
title: 操作系统知识点整理 (二)
aside:
  toc: true
key: 操作系统
---

# 3 计算机体系结构及内存分层体系
- 计算机体系结构/内存分层体系
- 地址空间 & 地址生成
- 连续内存分配

## 3.1 计算机体系结构/内存分层体系
- 计算机体系结构 （图片：计算机基本硬件结构）

- 内存分层体系
（图片：内存层次结构）

- 在操作系统的内存管理范例
操作系统需要完成的*四个目标*
1. **抽象：**希望应用程序在内存中运行时由于操作系统的有效管理而不需要去考虑底层的细节，只需要访问连续的地址空间（逻辑地址空间）
2. **保护：** 内存中可以运行多个地址空间， 需要有效的机制，有效的保护和隔离进程之间的地址空间
3. **共享：** 除隔离以外，进程之间有可能交互
4. **虚拟化：** 将最需要放入内存的数据放在内存中，暂时不用访问的数据放在硬盘

- 在操作系统中管理内存的不同方法
	- 程序重定位
	- 分段
	- 分页
	- 虚拟内存
	- 按需分页虚拟内存

- 实现高度依赖于硬件
	- 必须知道内存架构
	- MMU（内存管理单元）：硬件组件负责处理CPU的内存访问请求


## 3.2 地址空间 & 地址生成
- 地址空间定义
	- 物理地址空间是和硬件直接对应的，比如内存条代表主存、硬盘。
	- 逻辑地址是指一个运行的应用程序所看到的地址空间，是一维线性地址空间，其实访问的逻辑地址空间都是落实在物理地址空间存在的。


- 地址生成

	- **逻辑地址生成**
	（图片：逻辑地址生成）
	
	从最开始的符号的逻辑地址到最终可以在内存中运行的逻辑地址，经过了一些转换过程基本上不需要操作系统去做任何的帮助，通过应用程序、编译器、loader都可以完成。即使我们将执行程序放入内存中，还是一个逻辑地址。

	- **物理地址生成**
	（图片：物理地址生成）

	**CPU方面：** 
	1. 当CPU要执行某条指令时，ALU（计算逻辑单元）需要这条指令的内容，发出带参数（逻辑地址）的请求 
	2. CPU中的MMU（内存管理单元）会去查找逻辑地址对应的映射表，是否存在对应的物理地址，如果没有则会去内存中找 
	3. 如果找到对应的物理地址过后，CPU的控制器会给主存发出一个请求，需要某个物理地址的内容（该内容就是某条指令的内容）

	**内存方面：** 
	4. 主存会把内存的内容通过总线传给CPU

	**操作系统方面：** 建立逻辑地址和物理地址之间的映射

- 地址安全检查
	
	- 操作系统需要确保每一个程序能够有效的访问地址空间，访问的地址空间包含两个部分：1.起始地址 2.长度	
	- 执行指令时CPU会查map，检查逻辑地址是否满足区域限制，如果不满足则返回内存异常



## 3.3 连续内存分配
- 内存碎片问题
- 分区的动态分配
	- 第一适配
	- 最佳适配
	- 最差适配
- 压缩式碎片整理
- 交换式碎片整理

### 3.3.1 内存碎片问题
当给一个运行的程序分配地址空间过后，会发现有一些空闲空间无法被利用，碎片分为两种：
1. 外部碎片：在分配单元间的未使用内存
2. 内部碎片：在分配单元中的未使用内存

### 3.3.2 分区的动态分配
- 简单的内存管理方法：
	- 当一个应用程序允许运行在内存中时，分配一个连续的区间
	- 分配一个连续的内存区间给运行的程序以访问数据

为此操作系统需要去管理，空闲和非空间，所以有三种分配算法：
1. **<u>第一适配</u>：** 为了分配n字节，使用满足比n大的第一个可用空闲块，将这个空闲块分配给应用程序
	
	**需求：** 按地址排序的空闲块列表；分配需要寻找一个适合的分区；重分配需要检查，看是否自由分区能合并于相邻的空闲分区

	**优点：** 简单；易于产生更大的空闲块，向着地址空间的结尾

	**缺点：** 外部碎片，因为两个空闲块的中间可能没办法使用到； 不确定性


2. **<u>最佳适配</u>：** 为了分配n字节，使用最小的可用空闲块，以致块的尺寸比n大
	
	**基本原理 & 实现：** 为了避免分割大空闲块；为了最小化外部碎片产生的尺寸
	
	**需求：** 按尺寸排列的空闲块列表；分配需要寻找一个合适的分区；重分配需要的搜索及合并于相连的空闲分区，若有
	
	**优点：** 当大部分分配是小尺寸时非常有效；比较简单
	
	**缺点：** 外部碎片；重分配慢；易产生很多没用的微小碎片


3. **<u>最差适配</u>：** 为了分配n字节，使用最大可用空闲块，以致块的尺寸比n大
	
	**基本原理 & 实现：** 为了避免有太多微小的碎片

	**需求：** 按尺寸排列的空闲列表；分配很快（获得最大的分区）；重分配需要合并于相邻的空闲分区，若有，然后调整分块列表

	**优点：** 假如分配时中等尺寸效果最好

	**缺点：** 重分配慢；外部碎片；易于破碎大的空闲块以致大分区无法被分配

### 3.3.3 连续内存分配：压缩式与交换式碎片整理
为了保证能有大的、连续的空闲块分配给应用程序，来提高利用率，介绍两个方法：
1. **<u>压缩式碎片整理</u>：** 将内存中运行的程序调整位置
	- 重置程序以合并孔洞
	- 要求所有程序时动态可重置的
	- 需要考虑什么时候挪动位置？内存拷贝的开销？

2. **<u>交换式碎片整理</u>：** 将等待的应用程序挪动从memory（内存）到disk（硬盘），当应用程序需要执行时则将应用程序放回到内存中
	- 运行程序需要更多的内存
	- 抢占等待的程序 & 回收它们的内存
	- 需要考虑什么程序被放入到硬盘中？什么时候进行换入换出操作？

