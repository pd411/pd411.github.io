---
layout: article
title: Handler 消息机制
aside:
  toc: true
key: Android
---

在一些情况下，开发者需要在子线程中进行网络请求，读取文件等耗时的 `I/O` 操作。但获取到数据以及操作完毕过后如何更新到 `UI` 上，我们知道由于Android的开发规范，导致无法在子线程中获取或者更新 `UI` 控件，否则导致异常：`ViewRootImpl$CalledFromWrongThreadException`。 我们如何去解决这个问题，就需要用到 `Handler` 消息机制。

Android 的消息机制主要是指 `Handler` 的运行机制以及 `MessageQueue` 和 `Looper`的工作机制，这三者为一个整体。Android 中有 `checkThread` 方法会去检查是否是在主线程中访问 `UI` ，为了保证不在主线程中进行耗时工作而导致 `ANR（Application Not Responding，一般情况下 Activity 的执行时间为5s，Broadcast 的执行时间为10s）`。同时不允许在子线程中访问 `UI`，是因为 UI 控件不是线程安全的。

<br/>

# Handler 的工作原理

`Handler` 创建时会采用当前线程的 `Looper`，或者为当前线程创建 `Looper`。不然会产生以下报错：

```
java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare()
```

之后内部的 `Looper` 以及 `MessageQueue` 就可以和 `Handler` 一起协同工作了。通过 *`Handler.post`* 方法将一个 `Runnable` 投递到 `Handler` 内部的 `Looper` 中处理，也可以通过 *`Handler.send`* 方法发送一个消息通过 `Looper` 进行处理。

具体过程是当 `Handler.send` 方法被调用之后会调用 `MessageQueue.enqueueMessage` 方法，将这个消息放入消息队列中。当 `Looper` 发现有新消息到来时，就会去处理这个消息，最终消息中的 `Runnable.run` 或者 `Handler.handleMessage` 会被调用。

!["handler工作流程"]({{site.url}}/assets/images/android/handler/Handler过程流程.png "handler流程")

## 相关概念

- 主线程（UI 线程、Main Thread）：当应用被启动时，会自动开启一个主线程用于处理 `UI` 控件的绘制与操作。

- 子线程（工作线程）：开发者手动开启的线程，用于处理耗时操作。

- 消息（message）：线程之间通信的数据单元，即 Handler 接收与发送的内容，存储通信信息。

- 消息队列（MessageQueue）：一种数据结构，用于保存 Handler 发送过来的消息。

- 处理者（Handler）：用于在同一个进程中，线程之间的通信。添加消息到消息队列，同时处理消息。

- 循环器（Looper）：用于循环等待消息，消息队列中一出现消息做出相应的处理。

<br/>

# Handler 消息机制分析

根据上面的内容，可以知道在 Handler 创建时采用的是当前线程的 Looper 作为内部的消息循环系统，如果没有 `Looper.prepare` 方法就会报错。所以我们将从 `Looper.prepare` 方法开始分析其源码：

```
public static void prepare() {
    prepare(true);
}

private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException("Only one Looper may be created per thread");
    }
    sThreadLocal.set(new Looper(quitAllowed));
}
```

首先，从上面的代码内容，我们可以观察到在 `Looper` 类中有一个 `ThreadLocal` 对象。该对用是一个数据存储类，下面的部分是对 `ThreadLocal` 的分析：

## ThreadLocal

`ThreadLocal` 是一个线程内部的数据存储类，可以在指定的线程中存储数据。通常情况下，当数据是以**线程**为作用域且不同线程具有不同的数据副本的时候使用。另外一个场景是对于复杂逻辑下的对象关系，比如监听器的传递。

在 Android 的消息机制中，如何保证获取到当前线程的 `Looper`，就可以通过 `ThreadLocal` 对象进行获取。

不同线程访问同一个 `ThreadLocal.get` 方法，`ThreadLocal` 内部从各自的线程中取出一个数组，然后再从数组中根据当前的 `ThreadLocal` 的索引去查找出相对应的 `value` 值。

查看 `ThreadLocal` 源码部分，可以观察到 `public class ThreadLocal<T>`，是一个泛型类，工作原理是根据 `get` 和 `set` 方法。

```
public void set(T value) {
    // 获取当前线程
    Thread t = Thread.currentThread();
    // 获取当前线程的 ThreadLocalMap
    ThreadLocalMap map = getMap(t);
    // 如果 map 不为空，则将参数放入到 map 中，否则创建ThreadLocalMap
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
```

上面的代码内容，可以观察到 `ThreadLocal` 通过一个 `ThreadLocalMap` 进行维护。 `ThreadLocalMap` 类似于一个 HashMap，以下是该类的源码部分：

```
static class ThreadLocalMap {
    // Entry 继承 WeakReference 弱引用，当内存不够时，未被引用的 Entry 会被清理。
    static class Entry extends WeakReference<ThreadLocal<?>> {
        /** The value associated with this ThreadLocal. */
        Object value;

        Entry(ThreadLocal<?> k, Object v) {
            super(k);
            value = v;
        }
    }

    /**
    * 构造一个新的包含初始映射,ThreadLocal映射的新映射，因此我们只在创建至少一个条目时创建一个。
    */
    ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
        // table 是Entry数组，初始化table
        table = new Entry[INITIAL_CAPACITY];
        // 建立索引
        int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
        // 将ThreadLocal作为key，传入的第一个对象为value
        table[i] = new Entry(firstKey, firstValue);
        size = 1;
        // 设置阈值，参考 HashMap 的构建原理
        setThreshold(INITIAL_CAPACITY);
    }

    /**
    * 从给定的parentMap构造一个包含所有map的新ThreadLocal。仅由createInheritedMap调用。
    */
    private ThreadLocalMap(ThreadLocalMap parentMap) {
        Entry[] parentTable = parentMap.table;
        int len = parentTable.length;
        setThreshold(len);
        table = new Entry[len];

        for (int j = 0; j < len; j++) {
            Entry e = parentTable[j];
            if (e != null) {
                @SuppressWarnings("unchecked")
                ThreadLocal<Object> key = (ThreadLocal<Object>) e.get();
                if (key != null) {
                    Object value = key.childValue(e.value);
                    Entry c = new Entry(key, value);
                    int h = key.threadLocalHashCode & (len - 1);
                    while (table[h] != null)
                        h = nextIndex(h, len);
                    table[h] = c;
                    size++;
                }
            }
        }
    }
}
```

说明一下这里建立索引的方式，是参考 HashMap 的构建方式。

之后观察 `get` 方法：

```
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
```

同样是一开始通过 `Thread.currentThread` 方法获取当前线程，在通过当前线程获取到 `ThreadLocalMap`，最后获取到 `Entry.value` 作为结果返回。而 `setInitialValue` 方法是用来创建一个全新的 `ThreadLocalMap`。

> ThreadLocal并不会产生内存泄露，因为ThreadLocalMap在选择key的时候，并不是直接选择ThreadLocal实例，而是ThreadLocal实例的弱引用。所以实际上从ThreadLocal设计角度来说是不会导致内存泄露的。


